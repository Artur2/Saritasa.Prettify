<?xml version="1.0"?>
<doc>
    <assembly>
        <name>StyleCop.Analyzers</name>
    </assembly>
    <members>
        <member name="T:StyleCop.Analyzers.AnalyzerCategory">
            <summary>
            Class defining the analyzer category constants.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.AnalyzerCategory.DocumentationRules">
            <summary>
            Category definition for documentation rules.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.AnalyzerCategory.LayoutRules">
            <summary>
            Category definition for layout rules.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.AnalyzerCategory.MaintainabilityRules">
            <summary>
            Category definition for maintainability rules.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.AnalyzerCategory.NamingRules">
            <summary>
            Category definition for naming rules.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.AnalyzerCategory.OrderingRules">
            <summary>
            Category definition for ordering rules.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.AnalyzerCategory.ReadabilityRules">
            <summary>
            Category definition for readability rules.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.AnalyzerCategory.SpacingRules">
            <summary>
            Category definition for spacing rules.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.AnalyzerCategory.SpecialRules">
            <summary>
            Category definition for special purpose rules.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.AnalyzerConstants.DisabledNoTests">
            <summary>
            Gets a reference value which can be passed to
            <see cref="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.String,System.String,System.String[])"/>
            to disable a diagnostic which is currently untested.
            </summary>
            <value>
            A reference value which can be passed to
            <see cref="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.String,System.String,System.String[])"/>
            to disable a diagnostic which is currently untested.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.AnalyzerConstants.DisabledAlternative">
            <summary>
            Gets a reference value which can be passed to
            <see cref="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.String,System.String,System.String[])"/>
            to indicate that the diagnostic is disabled by default because it is an alternative to a reference StyleCop
            rule.
            </summary>
            <value>
            A reference value which can be passed to
            <see cref="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.String,System.String,System.String[])"/>
            to indicate that the diagnostic is disabled by default because it is an alternative to a reference StyleCop
            rule.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.AnalyzerConstants.EnabledByDefault">
            <summary>
            Gets a reference value which can be passed to
            <see cref="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.String,System.String,System.String[])"/>
            to indicate that the diagnostic should be enabled by default.
            </summary>
            <value>
            A reference value which can be passed to
            <see cref="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.String,System.String,System.String[])"/>
            to indicate that the diagnostic should be enabled by default.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.AnalyzerConstants.DisabledByDefault">
            <summary>
            Gets a reference value which can be passed to
            <see cref="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.String,System.String,System.String[])"/>
            to indicate that the diagnostic should be disabled by default.
            </summary>
            <value>
            A reference value which can be passed to
            <see cref="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.String,System.String,System.String[])"/>
            to indicate that the diagnostic should be disabled by default.
            </value>
        </member>
        <member name="T:StyleCop.Analyzers.AnalyzerExtensions">
            <summary>
            Provides extension methods to deal for analyzers.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.AnalyzerExtensions.RegisterSyntaxTreeAction(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext,System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext,StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings})">
            <summary>
            Register an action to be executed at completion of parsing of a code document. A syntax tree action reports
            diagnostics about the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> of a document.
            </summary>
            <param name="context">The analysis context.</param>
            <param name="action">Action to be executed at completion of parsing of a document.</param>
        </member>
        <member name="M:StyleCop.Analyzers.AnalyzerExtensions.RegisterSyntaxTreeAction(Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext,System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext,StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings})">
            <summary>
            Register an action to be executed at completion of parsing of a code document. A syntax tree action reports
            diagnostics about the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> of a document.
            </summary>
            <param name="context">The analysis context.</param>
            <param name="action">Action to be executed at completion of parsing of a document.</param>
        </member>
        <member name="M:StyleCop.Analyzers.AnalyzerExtensions.RegisterSyntaxNodeAction``1(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext,System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings},``0)">
            <summary>
            Register an action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> with an
            appropriate kind. A syntax node action can report diagnostics about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>, and can also
            collect state information to be used by other syntax node actions or code block end actions.
            </summary>
            <param name="context">The analysis context.</param>
            <param name="action">Action to be executed at completion of semantic analysis of a
            <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.</param>
            <param name="syntaxKind">The kind of syntax that should be analyzed.</param>
            <typeparam name="TLanguageKindEnum">Enum type giving the syntax node kinds of the source language for which
            the action applies.</typeparam>
        </member>
        <member name="M:StyleCop.Analyzers.AnalyzerExtensions.RegisterSyntaxNodeAction``1(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext,System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings},System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Register an action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> with an
            appropriate kind. A syntax node action can report diagnostics about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>, and can also
            collect state information to be used by other syntax node actions or code block end actions.
            </summary>
            <param name="context">The analysis context.</param>
            <param name="action">Action to be executed at completion of semantic analysis of a
            <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.</param>
            <param name="syntaxKinds">The kinds of syntax that should be analyzed.</param>
            <typeparam name="TLanguageKindEnum">Enum type giving the syntax node kinds of the source language for which
            the action applies.</typeparam>
        </member>
        <member name="M:StyleCop.Analyzers.AnalyzerExtensions.RegisterSyntaxNodeAction``1(Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext,System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings},``0)">
            <summary>
            Register an action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> with an
            appropriate kind. A syntax node action can report diagnostics about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>, and can also
            collect state information to be used by other syntax node actions or code block end actions.
            </summary>
            <param name="context">The analysis context.</param>
            <param name="action">Action to be executed at completion of semantic analysis of a
            <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.</param>
            <param name="syntaxKind">The kind of syntax that should be analyzed.</param>
            <typeparam name="TLanguageKindEnum">Enum type giving the syntax node kinds of the source language for which
            the action applies.</typeparam>
        </member>
        <member name="M:StyleCop.Analyzers.AnalyzerExtensions.RegisterSyntaxNodeAction``1(Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext,System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings},System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Register an action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> with an
            appropriate kind. A syntax node action can report diagnostics about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>, and can also
            collect state information to be used by other syntax node actions or code block end actions.
            </summary>
            <param name="context">The analysis context.</param>
            <param name="action">Action to be executed at completion of semantic analysis of a
            <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.</param>
            <param name="syntaxKinds">The kinds of syntax that should be analyzed.</param>
            <typeparam name="TLanguageKindEnum">Enum type giving the syntax node kinds of the source language for which
            the action applies.</typeparam>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.DocumentationResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.InheritdocCodeFix">
            <summary>
              Looks up a localized string similar to Inherit documentation.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.PropertySummaryStartTextCodeFix">
            <summary>
              Looks up a localized string similar to Add standard text.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1609SA1610CodeFix">
            <summary>
              Looks up a localized string similar to Document value from summary.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1611Description">
            <summary>
              Looks up a localized string similar to A C# method, constructor, delegate or indexer element is missing documentation for one or more of its parameters..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1611MessageFormat">
            <summary>
              Looks up a localized string similar to The documentation for parameter &apos;{0}&apos; is missing.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1611Title">
            <summary>
              Looks up a localized string similar to Element parameters must be documented.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1615SA1616CodeFix">
            <summary>
              Looks up a localized string similar to Document return value.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1617CodeFix">
            <summary>
              Looks up a localized string similar to Remove &lt;returns&gt; XML comment.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1623Description">
            <summary>
              Looks up a localized string similar to The documentation text within a C# property’s &lt;summary&gt; tag does not match the accessors within the property..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1623MessageFormat">
            <summary>
              Looks up a localized string similar to The property&apos;s documentation summary text must begin with: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1623Title">
            <summary>
              Looks up a localized string similar to Property summary documentation must match accessors.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1624Description">
            <summary>
              Looks up a localized string similar to The documentation text within a C# property’s &lt;summary&gt; tag takes into account all of the accessors within the property, but one of the accessors has limited access..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1624MessageFormat">
            <summary>
              Looks up a localized string similar to Because the property only contains a visible {0} accessor, the documentation summary text must begin with &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1624Title">
            <summary>
              Looks up a localized string similar to Property summary documentation must omit accessor with restricted access.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1626CodeFix">
            <summary>
              Looks up a localized string similar to Convert to line comment.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1627Description">
            <summary>
              Looks up a localized string similar to The XML header documentation for a C# code element contains an empty tag..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1627MessageFormat">
            <summary>
              Looks up a localized string similar to The documentation text within the \&apos;{0}\&apos; tag must not be empty..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1627Title">
            <summary>
              Looks up a localized string similar to Documentation text must not be empty.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1633CodeFix">
            <summary>
              Looks up a localized string similar to Add file header.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1633Description">
            <summary>
              Looks up a localized string similar to A C# code file is missing a standard file header..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1633MessageFormatMalformed">
            <summary>
              Looks up a localized string similar to The file header XML is invalid..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1633MessageFormatMissing">
            <summary>
              Looks up a localized string similar to The file header is missing or not located at the top of the file..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1633Title">
            <summary>
              Looks up a localized string similar to File must have header.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1634Description">
            <summary>
              Looks up a localized string similar to The file header at the top of a C# code file is missing a copyright tag..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1634MessageFormat">
            <summary>
              Looks up a localized string similar to The file header must contain a copyright tag..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1634Title">
            <summary>
              Looks up a localized string similar to File header must show copyright.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1635Description">
            <summary>
              Looks up a localized string similar to The file header at the top of a C# code file is missing copyright text..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1635MessageFormat">
            <summary>
              Looks up a localized string similar to File header must have copyright text.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1635Title">
            <summary>
              Looks up a localized string similar to File header must have copyright text.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1636Description">
            <summary>
              Looks up a localized string similar to The file header at the top of a C# code file does not contain the appropriate copyright text..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1636MessageFormat">
            <summary>
              Looks up a localized string similar to The file header copyright text must match the copyright text from the settings..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1636Title">
            <summary>
              Looks up a localized string similar to File header copyright text must match.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1637Description">
            <summary>
              Looks up a localized string similar to The file header at the top of a C# code file is missing the file name..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1637MessageFormat">
            <summary>
              Looks up a localized string similar to File header must contain file name..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1637Title">
            <summary>
              Looks up a localized string similar to File header must contain file name.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1638Description">
            <summary>
              Looks up a localized string similar to The file attribute within copyright tag of the file header at the top of a C# code file does not contain the name of the file..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1638MessageFormat">
            <summary>
              Looks up a localized string similar to File header file name documentation must match file name..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1638Title">
            <summary>
              Looks up a localized string similar to File header file name documentation must match file name.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1639Description">
            <summary>
              Looks up a localized string similar to The file header at the top of a C# code file does not contain a filled-in summary tag..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1639MessageFormat">
            <summary>
              Looks up a localized string similar to File header must have summary.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1639Title">
            <summary>
              Looks up a localized string similar to File header must have summary.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1640Description">
            <summary>
              Looks up a localized string similar to The file header at the top of a C# code file does not contain company name text..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1640MessageFormat">
            <summary>
              Looks up a localized string similar to The copyright tag must contain a non-empty company attribute..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1640Title">
            <summary>
              Looks up a localized string similar to File header must have valid company text.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1641Description">
            <summary>
              Looks up a localized string similar to The file header at the top of a C# code file does not contain the appropriate company name text..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1641MessageFormat">
            <summary>
              Looks up a localized string similar to The file header company name must match the company name from the settings..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1641Title">
            <summary>
              Looks up a localized string similar to File header company name text must match.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1642SA1643CodeFix">
            <summary>
              Looks up a localized string similar to Add standard text.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1648Description">
            <summary>
              Looks up a localized string similar to &lt;inheritdoc&gt; has been used on an element that doesn&apos;t inherit from a base class or implement an interface..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1648MessageFormat">
            <summary>
              Looks up a localized string similar to inheritdoc must be used with inheriting class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1648Title">
            <summary>
              Looks up a localized string similar to inheritdoc must be used with inheriting class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1649CodeFix">
            <summary>
              Looks up a localized string similar to Rename file to match first type name.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1649Description">
            <summary>
              Looks up a localized string similar to The file name of a C# code file does not match the first type declared in the file..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1649MessageFormat">
            <summary>
              Looks up a localized string similar to File name must match first type name..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1649Title">
            <summary>
              Looks up a localized string similar to File name must match first type name.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.SA1651CodeFix">
            <summary>
              Looks up a localized string similar to Finalize placeholder text.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.StartingTextGets">
            <summary>
              Looks up a localized string similar to Gets.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.StartingTextGetsOrSets">
            <summary>
              Looks up a localized string similar to Gets or sets.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.StartingTextGetsOrSetsWhether">
            <summary>
              Looks up a localized string similar to Gets or sets a value indicating whether.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.StartingTextGetsWhether">
            <summary>
              Looks up a localized string similar to Gets a value indicating whether.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.StartingTextSets">
            <summary>
              Looks up a localized string similar to Sets.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.DocumentationResources.StartingTextSetsWhether">
            <summary>
              Looks up a localized string similar to Sets a value indicating whether.
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.ElementDocumentationBase">
            <summary>
            This is the base class for analyzers which examine the <c>&lt;param&gt;</c> text of a documentation comment on an element declaration.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.ElementDocumentationBase.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.ElementDocumentationBase.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.Location[])">
            <summary>
            Analyzes the top-level elements of a documentation comment.
            </summary>
            <param name="context">The current analysis context.</param>
            <param name="syntaxList">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax"/> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax"/> of the node
            to examine.</param>
            <param name="diagnosticLocations">The location(s) where diagnostics, if any, should be reported.</param>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.ElementDocumentationBase.HandleCompleteDocumentation(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Xml.Linq.XElement,Microsoft.CodeAnalysis.Location[])">
            <summary>
            Analyzes the XML elements of a documentation comment.
            </summary>
            <param name="context">The current analysis context.</param>
            <param name="completeDocumentation">The complete documentation for the declared symbol, with any
            <c>&lt;include&gt;</c> elements expanded. If the XML documentation comment included a <c>&lt;param&gt;</c>
            element, this value will be <see langword="null"/>, even if the XML documentation comment also included an
            <c>&lt;include&gt;</c> element.</param>
            <param name="diagnosticLocations">The location(s) where diagnostics, if any, should be reported.</param>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.ElementDocumentationSummaryBase">
            <summary>
            This is the base class for analyzers which examine the <c>&lt;summary&gt;</c> text of a documentation comment.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.ElementDocumentationSummaryBase.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.ElementDocumentationSummaryBase.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax,System.Xml.Linq.XElement,Microsoft.CodeAnalysis.Location[])">
            <summary>
            Analyzes the top-level <c>&lt;summary&gt;</c> element of a documentation comment.
            </summary>
            <param name="context">The current analysis context.</param>
            <param name="documentation">The documentation syntax associated with the element.</param>
            <param name="syntax">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax"/> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax"/> of the node
            to examine.</param>
            <param name="completeDocumentation">The complete documentation for the declared symbol, with any
            <c>&lt;include&gt;</c> elements expanded. If the XML documentation comment included a <c>&lt;summary&gt;</c>
            element, this value will be <see langword="null"/>, even if the XML documentation comment also included an
            <c>&lt;include&gt;</c> element.</param>
            <param name="diagnosticLocations">The location(s) where diagnostics, if any, should be reported.</param>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers">
            <summary>
            Analyzer for all file header related diagnostics.
            </summary>
            <seealso href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1633.md">SA1633 File must have header</seealso>
            <seealso href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1634.md">SA1634 File header must show copyright</seealso>
            <seealso href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1635.md">SA1635 File header must have copyright text</seealso>
            <seealso href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1636.md">SA1636 File header copyright text must match</seealso>
            <seealso href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1637.md">SA1637 File header must contain file name</seealso>
            <seealso href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1638.md">SA1638 File header file name documentation must match file name</seealso>
            <seealso href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1639.md">SA1639 File header must have summary</seealso>
            <seealso href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1640.md">SA1640 File header must have valid company text</seealso>
            <seealso href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1641.md">SA1641 File header company name text must match</seealso>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers.SA1633DescriptorMissing">
            <summary>
            Gets the diagnostic descriptor for SA1633 with a missing header.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1633.</value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers.SA1633DescriptorMalformed">
            <summary>
            Gets the diagnostic descriptor for SA1633 with a malformed header.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1633.</value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers.SA1634Descriptor">
            <summary>
            Gets the diagnostic descriptor for SA1634.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1634.</value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers.SA1635Descriptor">
            <summary>
            Gets the diagnostic descriptor for SA1635.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1635.</value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers.SA1636Descriptor">
            <summary>
            Gets the diagnostic descriptor for SA1636.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1636.</value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers.SA1637Descriptor">
            <summary>
            Gets the diagnostic descriptor for SA1637.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1637.</value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers.SA1638Descriptor">
            <summary>
            Gets the diagnostic descriptor for SA1638.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1638.</value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers.SA1639Descriptor">
            <summary>
            Gets the diagnostic descriptor for SA1639.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1639.</value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers.SA1640Descriptor">
            <summary>
            Gets the diagnostic descriptor for SA1640.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1640.</value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers.SA1641Descriptor">
            <summary>
            Gets the diagnostic descriptor for SA1641.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1641.</value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.PartialElementDocumentationSummaryBase">
            <summary>
            This is the base class for analyzers which examine the <c>&lt;summary&gt;</c> or <c>&lt;content&gt;</c> text of
            the documentation comment associated with a <c>partial</c> element.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.PartialElementDocumentationSummaryBase.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.PartialElementDocumentationSummaryBase.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.Location[])">
            <summary>
            Analyzes the top-level <c>&lt;summary&gt;</c> or <c>&lt;content&gt;</c> element of a documentation comment.
            </summary>
            <param name="context">The current analysis context.</param>
            <param name="syntax">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax"/> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax"/> of the node
            to examine.</param>
            <param name="diagnosticLocations">The location(s) where diagnostics, if any, should be reported.</param>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.PropertyDocumentationBase">
            <summary>
            This is the base class for analyzers which examine the <c>&lt;value&gt;</c> text of a documentation comment on a property declaration.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.PropertyDocumentationBase.XmlTagToHandle">
            <summary>
            Gets the XML tag within the property documentation that should be handled.
            </summary>
            <value>The XML tag to handle.</value>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.PropertyDocumentationBase.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.PropertyDocumentationBase.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.Location)">
            <summary>
            Analyzes the top-level <c>&lt;summary&gt;</c> element of a documentation comment.
            </summary>
            <param name="context">The current analysis context.</param>
            <param name="syntax">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax"/> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax"/> of the node
            to examine.</param>
            <param name="diagnosticLocation">The location where diagnostics, if any, should be reported.</param>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.PropertySummaryDocumentationAnalyzer">
            <summary>
            Analyzes the correct usage of property summary documentation.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.PropertySummaryDocumentationAnalyzer.SA1623Descriptor">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1623.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1623.</value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.PropertySummaryDocumentationAnalyzer.SA1624Descriptor">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1624.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1624.</value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.PropertySummaryDocumentationAnalyzer.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.PropertySummaryDocumentationAnalyzer.XmlTagToHandle">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.PropertySummaryDocumentationAnalyzer.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.Location)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1600ElementsMustBeDocumented">
             <summary>
             A C# code element is missing a documentation header.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of Xml documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx"/>.</para>
            
             <para>A violation of this rule occurs if an element is completely missing a documentation header, or if the
             header is empty. In C# the following types of elements can have documentation headers: classes, constructors,
             delegates, enums, events, finalizers, indexers, interfaces, methods, properties, and structs.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1600ElementsMustBeDocumented.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1600ElementsMustBeDocumented"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1600ElementsMustBeDocumented.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1600ElementsMustBeDocumented.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1601PartialElementsMustBeDocumented">
             <summary>
             A C# partial element is missing a documentation header.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs if a partial element (an element with the partial attribute) is completely
             missing a documentation header, or if the header is empty. In C# the following types of elements can be
             attributed with the partial attribute: classes, methods.</para>
            
             <para>When documentation is provided on more than one part of the partial class, the documentation for the two
             classes may be merged together to form a single source of documentation. For example, consider the following two
             parts of a partial class:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Documentation for the first part of Class1.
             /// &lt;/summary&gt;
             public partial class Class1
             {
             }
            
             /// &lt;summary&gt;
             /// Documentation for the second part of Class1.
             /// &lt;/summary&gt;
             public partial class Class1
             {
             }
             </code>
            
             <para>These two different parts of the same partial class each provide different documentation for the class.
             When the documentation for this class is built into an SDK, the tool building the documentation will either
             choose to use only one part of the documentation for the class and ignore the other parts, or, in some cases, it
             may merge the two sources of documentation together, to form a string like: "Documentation for the first part of
             Class1. Documentation for the second part of Class1."</para>
            
             <para>For these reasons, it can be problematic to provide SDK documentation on more than one part of the partial
             class. However, it is still advisable to document each part of the class, to increase the readability and
             maintainability of the code, and StyleCop will require that each part of the class contain header
             documentation.</para>
            
             <para>This problem is solved through the use of the <c>&lt;content&gt;</c> tag, which can replace the
             <c>&lt;summary&gt;</c> tag for partial classes. The recommended practice for documenting partial classes is to
             provide the official SDK documentation for the class on the main part of the partial class. This documentation
             should be written using the standard <c>&lt;summary&gt;</c> tag. All other parts of the partial class should
             omit the <c>&lt;summary&gt;</c> tag completely, and replace it with a <c>&lt;content&gt;</c> tag. This allows
             the developer to document all parts of the partial class while still centralizing all of the official SDK
             documentation for the class onto one part of the class. The <c>&lt;content&gt;</c> tags will be ignored by the
             SDK documentation tools.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1601PartialElementsMustBeDocumented.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1601PartialElementsMustBeDocumented"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1601PartialElementsMustBeDocumented.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1601PartialElementsMustBeDocumented.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1602EnumerationItemsMustBeDocumented">
             <summary>
             An item within a C# enumeration is missing an XML documentation header.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when an item within an enumeration is missing a header. For
             example:</para>
            
             <code>
             /// &lt;summary&gt;
             /// Types of animals.
             /// &lt;/summary&gt;
             public enum Animals
             {
                 Dog,
                 Cat,
                 Horse
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1602EnumerationItemsMustBeDocumented.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1602EnumerationItemsMustBeDocumented"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1602EnumerationItemsMustBeDocumented.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1602EnumerationItemsMustBeDocumented.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1603DocumentationMustContainValidXml">
             <summary>
             The XML within a C# element's document header is badly formed.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when the documentation XML is badly formed and cannot be parsed. This can
             occur if the XML contains invalid characters, or if an XML node is missing a closing tag, for example.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1603DocumentationMustContainValidXml.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1603DocumentationMustContainValidXml"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1603DocumentationMustContainValidXml.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1603DocumentationMustContainValidXml.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1604ElementDocumentationMustHaveSummary">
             <summary>
             The XML header documentation for a C# element is missing a <c>&lt;summary&gt;</c> tag.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when the element documentation is missing a <c>&lt;summary&gt;</c>
             tag.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1604ElementDocumentationMustHaveSummary.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1604ElementDocumentationMustHaveSummary"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1604ElementDocumentationMustHaveSummary.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1604ElementDocumentationMustHaveSummary.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax,System.Xml.Linq.XElement,Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1605PartialElementDocumentationMustHaveSummary">
             <summary>
             The <c>&lt;summary&gt;</c> or <c>&lt;content&gt;</c> tag within the documentation header for a C# code element
             is missing or empty.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when the documentation header for a partial element (an element with the
             partial attribute) is missing a <c>&lt;summary&gt;</c> or <c>&lt;content&gt;</c> tag, or contains an empty
             <c>&lt;summary&gt;</c> or <c>&lt;content&gt;</c> tag which does not contain a description of the element. In C#
             the following types of elements can be attributed with the partial attribute: classes, methods.</para>
            
             <para>When documentation is provided on more than one part of the partial class, the documentation for the two
             classes may be merged together to form a single source of documentation. For example, consider the following two
             parts of a partial class:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Documentation for the first part of Class1.
             /// &lt;/summary&gt;
             public partial class Class1
             {
             }
            
             /// &lt;summary&gt;
             /// Documentation for the second part of Class1.
             /// &lt;/summary&gt;
             public partial class Class1
             {
             }
             </code>
            
             <para>These two different parts of the same partial class each provide different documentation for the class.
             When the documentation for this class is built into an SDK, the tool building the documentation will either
             choose to use only one part of the documentation for the class and ignore the other parts, or, in some cases, it
             may merge the two sources of documentation together, to form a string like: "Documentation for the first part of
             Class1. Documentation for the second part of Class1."</para>
            
             <para>For these reasons, it can be problematic to provide SDK documentation on more than one part of the partial
             class. However, it is still advisable to document each part of the class, to increase the readability and
             maintainability of the code, and StyleCop will require that each part of the class contain header
             documentation.</para>
            
             <para>This problem is solved through the use of the <c>&lt;content&gt;</c> tag, which can replace the
             <c>&lt;summary&gt;</c> tag for partial classes. The recommended practice for documenting partial classes is to
             provide the official SDK documentation for the class on the main part of the partial class. This documentation
             should be written using the standard <c>&lt;summary&gt;</c> tag. All other parts of the partial class should
             omit the <c>&lt;summary&gt;</c> tag completely, and replace it with a <c>&lt;content&gt;</c> tag. This allows
             the developer to document all parts of the partial class while still centralizing all of the official SDK
             documentation for the class onto one part of the class. The <c>&lt;content&gt;</c> tags will be ignored by the
             SDK documentation tools.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1605PartialElementDocumentationMustHaveSummary.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1605PartialElementDocumentationMustHaveSummary"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1605PartialElementDocumentationMustHaveSummary.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1605PartialElementDocumentationMustHaveSummary.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1606ElementDocumentationMustHaveSummaryText">
             <summary>
             The <c>&lt;summary&gt;</c> tag within the documentation header for a C# code element is empty.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when the documentation header for an element contains an empty
             <c>&lt;summary&gt;</c> tag which does not contain a description of the element.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1606ElementDocumentationMustHaveSummaryText.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1606ElementDocumentationMustHaveSummaryText"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1606ElementDocumentationMustHaveSummaryText.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1606ElementDocumentationMustHaveSummaryText.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax,System.Xml.Linq.XElement,Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1607PartialElementDocumentationMustHaveSummaryText">
             <summary>
             The <c>&lt;summary&gt;</c> or <c>&lt;content&gt;</c> tag within the documentation header for a C# code element
             is empty.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when the documentation header for a partial element (an element with the
             partial attribute) contains an empty <c>&lt;summary&gt;</c> tag or <c>&lt;content&gt;</c> tag which does not
             contain a description of the element. In C# the following types of elements can be attributed with the partial
             attribute: classes, methods.</para>
            
             <para>When documentation is provided on more than one part of the partial class, the documentation for the two
             classes may be merged together to form a single source of documentation. For example, consider the following two
             parts of a partial class:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Documentation for the first part of Class1.
             /// &lt;/summary&gt;
             public partial class Class1
             {
             }
            
             /// &lt;summary&gt;
             /// Documentation for the second part of Class1.
             /// &lt;/summary&gt;
             public partial class Class1
             {
             }
             </code>
            
             <para>These two different parts of the same partial class each provide different documentation for the class.
             When the documentation for this class is built into an SDK, the tool building the documentation will either
             choose to use only one part of the documentation for the class and ignore the other parts, or, in some cases, it
             may merge the two sources of documentation together, to form a string like: "Documentation for the first part of
             Class1. Documentation for the second part of Class1."</para>
            
             <para>For these reasons, it can be problematic to provide SDK documentation on more than one part of the partial
             class. However, it is still advisable to document each part of the class, to increase the readability and
             maintainability of the code, and StyleCop will require that each part of the class contain header
             documentation.</para>
            
             <para>This problem is solved through the use of the <c>&lt;content&gt;</c> tag, which can replace the
             <c>&lt;summary&gt;</c> tag for partial classes. The recommended practice for documenting partial classes is to
             provide the official SDK documentation for the class on the main part of the partial class. This documentation
             should be written using the standard <c>&lt;summary&gt;</c> tag. All other parts of the partial class should
             omit the <c>&lt;summary&gt;</c> tag completely, and replace it with a <c>&lt;content&gt;</c> tag. This allows
             the developer to document all parts of the partial class while still centralizing all of the official SDK
             documentation for the class onto one part of the class. The <c>&lt;content&gt;</c> tags will be ignored by the
             SDK documentation tools.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1607PartialElementDocumentationMustHaveSummaryText.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1607PartialElementDocumentationMustHaveSummaryText"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1607PartialElementDocumentationMustHaveSummaryText.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1607PartialElementDocumentationMustHaveSummaryText.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1608ElementDocumentationMustNotHaveDefaultSummary">
             <summary>
             The <c>&lt;summary&gt;</c> tag within an element's XML header documentation contains the default text generated
             by Visual Studio during the creation of the element.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>Visual Studio provides helper functionality for adding new elements such as classes to a project. Visual
             Studio will create a default documentation header for the new class and fill in this header with default
             documentation text.</para>
            
             <para>A violation of this rule occurs when the <c>&lt;summary&gt;</c> tag for a code element still contains the
             default documentation text generated by Visual Studio.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1608ElementDocumentationMustNotHaveDefaultSummary.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1608ElementDocumentationMustNotHaveDefaultSummary"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1608ElementDocumentationMustNotHaveDefaultSummary.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1608ElementDocumentationMustNotHaveDefaultSummary.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1608ElementDocumentationMustNotHaveDefaultSummary.HandleCompleteDocumentation(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Xml.Linq.XElement,Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1609PropertyDocumentationMustHaveValue">
             <summary>
             The XML header documentation for a C# property does not contain a <c>&lt;value&gt;</c> tag.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>The documentation for properties may include a <c>&lt;value&gt;</c> tag, which describes the value held by
             the property.</para>
            
             <para>A violation of this rule occurs when the <c>&lt;value&gt;</c> tag for a property is missing.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1609PropertyDocumentationMustHaveValue.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1609PropertyDocumentationMustHaveValue"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1609PropertyDocumentationMustHaveValue.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1609PropertyDocumentationMustHaveValue.XmlTagToHandle">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1609PropertyDocumentationMustHaveValue.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.Location)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1610PropertyDocumentationMustHaveValueText">
             <summary>
             The XML header documentation for a C# property contains an empty <c>&lt;value&gt;</c> tag.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>The documentation for properties may include a <c>&lt;value&gt;</c> tag, which describes the value held by
             the property.</para>
            
             <para>A violation of this rule occurs when the <c>&lt;value&gt;</c> tag for a property is empty.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1610PropertyDocumentationMustHaveValueText.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1610PropertyDocumentationMustHaveValueText"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1610PropertyDocumentationMustHaveValueText.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1610PropertyDocumentationMustHaveValueText.XmlTagToHandle">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1610PropertyDocumentationMustHaveValueText.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax,Microsoft.CodeAnalysis.Location)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1611ElementParametersMustBeDocumented">
             <summary>
             A C# method, constructor, delegate or indexer element is missing documentation for one or more of its
             parameters.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs if an element containing parameters is missing documentation for one or
             more of its parameters.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1611ElementParametersMustBeDocumented.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1611ElementParametersMustBeDocumented"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1611ElementParametersMustBeDocumented.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1611ElementParametersMustBeDocumented.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1611ElementParametersMustBeDocumented.HandleCompleteDocumentation(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Xml.Linq.XElement,Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1612ElementParameterDocumentationMustMatchElementParameters">
             <summary>
             The documentation describing the parameters to a C# method, constructor, delegate or indexer element does not
             match the actual parameters on the element.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs if the documentation for an element's parameters does not match the actual
             parameters on the element, or if the parameter documentation is not listed in the same order as the element's parameters.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1612ElementParameterDocumentationMustMatchElementParameters.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1612ElementParameterDocumentationMustMatchElementParameters"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1612ElementParameterDocumentationMustMatchElementParameters.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1612ElementParameterDocumentationMustMatchElementParameters.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1612ElementParameterDocumentationMustMatchElementParameters.HandleCompleteDocumentation(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Xml.Linq.XElement,Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1613ElementParameterDocumentationMustDeclareParameterName">
             <summary>
             A <c>&lt;param&gt;</c> tag within a C# element's documentation header is missing a <c>name</c> attribute
             containing the name of the parameter.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs if the documentation for an element contains a <c>&lt;param&gt;</c> tag
             which is missing a <c>name</c> attribute, or which contains an empty <c>name</c> attribute.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1613ElementParameterDocumentationMustDeclareParameterName.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1613ElementParameterDocumentationMustDeclareParameterName"/> analyzer.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1613ElementParameterDocumentationMustDeclareParameterName.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1613ElementParameterDocumentationMustDeclareParameterName"/> class.
            </summary>
            <remarks>The presence of a &lt;inheritdoc/&gt; tag should NOT suppress warnings from this diagnostic. See DotNetAnalyzers/StyleCopAnalyzers#631</remarks>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1613ElementParameterDocumentationMustDeclareParameterName.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1613ElementParameterDocumentationMustDeclareParameterName.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1613ElementParameterDocumentationMustDeclareParameterName.HandleCompleteDocumentation(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Xml.Linq.XElement,Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1614ElementParameterDocumentationMustHaveText">
             <summary>
             A <c>&lt;param&gt;</c> tag within a C# element's documentation header is empty.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs if the documentation for an element contains a <c>&lt;param&gt;</c> tag
             which is empty and does not contain a description of the parameter.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1614ElementParameterDocumentationMustHaveText.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1614ElementParameterDocumentationMustHaveText"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1614ElementParameterDocumentationMustHaveText.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1614ElementParameterDocumentationMustHaveText.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1614ElementParameterDocumentationMustHaveText.HandleCompleteDocumentation(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Xml.Linq.XElement,Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1615ElementReturnValueMustBeDocumented">
             <summary>
             A C# element is missing documentation for its return value.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs if an element containing a return value is missing a
             <c>&lt;returns&gt;</c> tag.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1615ElementReturnValueMustBeDocumented.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1615ElementReturnValueMustBeDocumented"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1615ElementReturnValueMustBeDocumented.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1615ElementReturnValueMustBeDocumented.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1616ElementReturnValueDocumentationMustHaveText">
             <summary>
             The <c>&lt;returns&gt;</c> tag within a C# element's documentation header is empty.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs if an element contains an empty <c>&lt;returns&gt;</c> tag.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1616ElementReturnValueDocumentationMustHaveText.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1616ElementReturnValueDocumentationMustHaveText"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1616ElementReturnValueDocumentationMustHaveText.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1616ElementReturnValueDocumentationMustHaveText.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1616ElementReturnValueDocumentationMustHaveText.HandleCompleteDocumentation(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Xml.Linq.XElement,Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1617VoidReturnValueMustNotBeDocumented">
             <summary>
             A C# code element does not contain a return value, or returns <c>void</c>, but the documentation header for the
             element contains a <c>&lt;returns&gt;</c> tag.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs if an element which returns <c>void</c> contains a <c>&lt;returns&gt;</c>
             tag within its documentation header.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1617VoidReturnValueMustNotBeDocumented.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1617VoidReturnValueMustNotBeDocumented"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1617VoidReturnValueMustNotBeDocumented.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1617VoidReturnValueMustNotBeDocumented.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1618GenericTypeParametersMustBeDocumented">
             <summary>
             A generic C# element is missing documentation for one or more of its generic type parameters.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs if an element containing generic type parameters is missing documentation
             for one or more of its generic type parameters.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1618GenericTypeParametersMustBeDocumented.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1618GenericTypeParametersMustBeDocumented"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1618GenericTypeParametersMustBeDocumented.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1618GenericTypeParametersMustBeDocumented.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1619GenericTypeParametersMustBeDocumentedPartialClass">
             <summary>
             A generic, partial C# element is missing documentation for one or more of its generic type parameters, and the
             documentation for the element contains a <c>&lt;summary&gt;</c> tag.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when a generic, partial element is missing documentation for one or more
             of its generic type parameters, and the documentation for the element contains a <c>&lt;summary&gt;</c> tag
             rather than a <c>&lt;content&gt;</c> tag.</para>
            
             <para>When documentation is provided on more than one part of the partial class, the documentation for the two
             classes may be merged together to form a single source of documentation. For example, consider the following two
             parts of a partial class:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Documentation for the first part of Class1.
             /// &lt;/summary&gt;
             public partial class Class1
             {
             }
            
             /// &lt;summary&gt;
             /// Documentation for the second part of Class1.
             /// &lt;/summary&gt;
             public partial class Class1
             {
             }
             </code>
            
             <para>These two different parts of the same partial class each provide different documentation for the class.
             When the documentation for this class is built into an SDK, the tool building the documentation will either
             choose to use only one part of the documentation for the class and ignore the other parts, or, in some cases, it
             may merge the two sources of documentation together, to form a string like: "Documentation for the first part of
             Class1. Documentation for the second part of Class1."</para>
            
             <para>For these reasons, it can be problematic to provide SDK documentation on more than one part of the partial
             class. However, it is still advisable to document each part of the class, to increase the readability and
             maintainability of the code, and StyleCop will require that each part of the class contain header
             documentation.</para>
            
             <para>This problem is solved through the use of the <c>&lt;content&gt;</c> tag, which can replace the
             <c>&lt;summary&gt;</c> tag for partial classes. The recommended practice for documenting partial classes is to
             provide the official SDK documentation for the class on the main part of the partial class. This documentation
             should be written using the standard <c>&lt;summary&gt;</c> tag. All other parts of the partial class should
             omit the <c>&lt;summary&gt;</c> tag completely, and replace it with a <c>&lt;content&gt;</c> tag. This allows
             the developer to document all parts of the partial class while still centralizing all of the official SDK
             documentation for the class onto one part of the class. The <c>&lt;content&gt;</c> tags will be ignored by the
             SDK documentation tools.</para>
            
             <para>When a generic element contains a <c>&lt;summary&gt;</c> tag within its documentation header, StyleCop
             assumes that this is the main part of the class, and requires the header to contain <c>&lt;typeparam&gt;</c>
             tags for each of the generic type parameters on the class. However, if the documentation header for the class
             contains a <c>&lt;content&gt;</c> tag rather than a <c>&lt;summary&gt;</c> tag, StyleCop will assume that the
             generic type parameters are defined on another part of the class, and will not require <c>&lt;typeparam&gt;</c>
             tags on this part of the class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1619GenericTypeParametersMustBeDocumentedPartialClass.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1619GenericTypeParametersMustBeDocumentedPartialClass"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1619GenericTypeParametersMustBeDocumentedPartialClass.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1619GenericTypeParametersMustBeDocumentedPartialClass.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1620GenericTypeParameterDocumentationMustMatchTypeParameters">
             <summary>
             The <c>&lt;typeparam&gt;</c> tags within the XML header documentation for a generic C# element do not match the
             generic type parameters on the element.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs if the <c>&lt;typeparam&gt;</c> tags within the element's header
             documentation do not match the generic type parameters on the element, or do not appear in the same order as the
             element's type parameters.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1620GenericTypeParameterDocumentationMustMatchTypeParameters.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1620GenericTypeParameterDocumentationMustMatchTypeParameters"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1620GenericTypeParameterDocumentationMustMatchTypeParameters.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1620GenericTypeParameterDocumentationMustMatchTypeParameters.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1620GenericTypeParameterDocumentationMustMatchTypeParameters.GetParentTypeParameters(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Checks if the given <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> has a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax"/>, a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax"/> or a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax"/>
            as one of its parent. If it finds one of those three with a valid type parameter list it returns a <see cref="T:System.Collections.Generic.IEnumerable`1"/> containing the names of all type parameters.
            </summary>
            <param name="node">The node the analysis should start at.</param>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> containing all type parameters or null, of no valid parent could be found.
            </returns>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1621GenericTypeParameterDocumentationMustDeclareParameterName">
             <summary>
             A <c>&lt;typeparam&gt;</c> tag within the XML header documentation for a generic C# element is missing a
             <c>name</c> attribute, or contains an empty <c>name</c> attribute.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs if the element contains a <c>&lt;typeparam&gt;</c> tag within its XML
             header documentation which does not declare the name of the type parameter.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1621GenericTypeParameterDocumentationMustDeclareParameterName.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1621GenericTypeParameterDocumentationMustDeclareParameterName"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1621GenericTypeParameterDocumentationMustDeclareParameterName.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1621GenericTypeParameterDocumentationMustDeclareParameterName.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1622GenericTypeParameterDocumentationMustHaveText">
             <summary>
             A <c>&lt;typeparam&gt;</c> tag within the XML header documentation for a generic C# element is empty.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs if the element contains an empty <c>&lt;typeparam&gt;</c> tag within its
             XML header documentation.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1622GenericTypeParameterDocumentationMustHaveText.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1622GenericTypeParameterDocumentationMustHaveText"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1622GenericTypeParameterDocumentationMustHaveText.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1622GenericTypeParameterDocumentationMustHaveText.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1625ElementDocumentationMustNotBeCopiedAndPasted">
             <summary>
             The XML documentation for a C# element contains two or more identical entries, indicating that the documentation
             has been copied and pasted. This can sometimes indicate invalid or poorly written documentation.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when an element contains two or more identical documentation texts. For
             example:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Joins a first name and a last name together into a single string.
             /// &lt;/summary&gt;
             /// &lt;param name="firstName"&gt;Part of the name.&lt;/param&gt;
             /// &lt;param name="lastName"&gt;Part of the name.&lt;/param&gt;
             /// &lt;returns&gt;The joined names.&lt;/returns&gt;
             public string JoinNames(string firstName, string lastName)
             {
                 return firstName + " " + lastName;
             }
             </code>
            
             <para>In some cases, a method may contain one or more parameters which are not used within the body of the
             method. In this case, the documentation for the parameter can be set to "The parameter is not used." StyleCop
             will allow multiple parameters to contain identical documentation as long as the documentation string is "The
             parameter is not used."</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Joins a first name and a last name together into a single string.
             /// &lt;/summary&gt;
             /// &lt;param name="firstName"&gt;The first name to join.&lt;/param&gt;
             /// &lt;param name="lastName"&gt;The last name to join.&lt;/param&gt;
             /// &lt;returns&gt;The joined names.&lt;/returns&gt;
             public string JoinNames(string firstName, string lastName)
             {
                 return firstName + " " + lastName;
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1625ElementDocumentationMustNotBeCopiedAndPasted.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1625ElementDocumentationMustNotBeCopiedAndPasted"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1625ElementDocumentationMustNotBeCopiedAndPasted.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1625ElementDocumentationMustNotBeCopiedAndPasted.HandleXmlElement(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1625ElementDocumentationMustNotBeCopiedAndPasted.HandleCompleteDocumentation(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Xml.Linq.XElement,Microsoft.CodeAnalysis.Location[])">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1626SingleLineCommentsMustNotUseDocumentationStyleSlashes">
             <summary>
             The C# code contains a single-line comment which begins with three forward slashes in a row.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the code contains a single-line comment which begins with three
             slashes. Comments beginning with three slashes are reserved for XML documentation headers. Single-line comments
             should begin with only two slashes. When commenting out lines of code, it is advisable to begin the comment with
             four slashes to differentiate it from normal comments. For example:</para>
            
             <code language="csharp">
                 /// &lt;summary&gt;
                 /// Joins a first name and a last name together into a single string.
                 /// &lt;/summary&gt;
                 /// &lt;param name="firstName"&gt;Part of the name.&lt;/param&gt;
                 /// &lt;param name="lastName"&gt;Part of the name.&lt;/param&gt;
                 /// &lt;returns&gt;The joined names.&lt;/returns&gt;
                 public string JoinNames(string firstName, string lastName)
                 {
             A legal comment beginning with two slashes:
                     // Join the names together.
                     string fullName = firstName + " " + lastName;
            
             An illegal comment beginning with three slashes:
                     /// Trim the name.
                     fullName = fullName.Trim();
            
             A line of commented-out code beginning with four slashes:
                     ////fullName = asfd;
            
                     return fullName;
                 }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1626SingleLineCommentsMustNotUseDocumentationStyleSlashes.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1626SingleLineCommentsMustNotUseDocumentationStyleSlashes"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1626SingleLineCommentsMustNotUseDocumentationStyleSlashes.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1626SingleLineCommentsMustNotUseDocumentationStyleSlashes.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1627DocumentationTextMustNotBeEmpty">
             <summary>
             The XML header documentation for a C# code element contains an empty tag.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when the documentation header for an element contains an empty tag. For
             example:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Joins a first name and a last name together into a single string.
             /// &lt;/summary&gt;
             /// &lt;remarks&gt;&lt;/remarks&gt;
             /// &lt;param name="firstName"&gt;Other part of name.&lt;/param&gt;
             /// &lt;param name="lastName"&gt;Part of the name.&lt;/param&gt;
             /// &lt;returns&gt;The joined names.&lt;/returns&gt;
             public string JoinNames(string firstName, string lastName)
             {
                 ...
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1627DocumentationTextMustNotBeEmpty.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1627DocumentationTextMustNotBeEmpty"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1627DocumentationTextMustNotBeEmpty.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1627DocumentationTextMustNotBeEmpty.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1628DocumentationTextMustBeginWithACapitalLetter">
             <summary>
             A section of the XML header documentation for a C# element does not begin with a capital letter.
             </summary>
             <remarks>
             <para>This diagnostic is not implemented in StyleCopAnalyzers.</para>
            
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when part of the documentation does not begin with a capital letter. For
             example, the summary text in the documentation below begins with a lower-case letter:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// joins a first name and a last name together into a single string.
             /// &lt;/summary&gt;
             /// &lt;param name="firstName"&gt;The first name.&lt;/param&gt;
             /// &lt;param name="lastName"&gt;The last name.&lt;/param&gt;
             /// &lt;returns&gt;The joined names.&lt;/returns&gt;
             public string JoinNames(string firstName, string lastName)
             {
                 ...
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1628DocumentationTextMustBeginWithACapitalLetter.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1628DocumentationTextMustBeginWithACapitalLetter"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1628DocumentationTextMustBeginWithACapitalLetter.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1628DocumentationTextMustBeginWithACapitalLetter.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1629DocumentationTextMustEndWithAPeriod">
             <summary>
             A section of the XML header documentation for a C# element does not end with a period (also known as a full
             stop).
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when part of the documentation does not end with a period. For example,
             the summary text in the documentation below does not end with a period:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Joins a first name and a last name together into a single string
             /// &lt;/summary&gt;
             /// &lt;param name="firstName"&gt;The first name.&lt;/param&gt;
             /// &lt;param name="lastName"&gt;The last name.&lt;/param&gt;
             /// &lt;returns&gt;The joined names.&lt;/returns&gt;
             public string JoinNames(string firstName, string lastName)
             {
                 ...
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1629DocumentationTextMustEndWithAPeriod.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1629DocumentationTextMustEndWithAPeriod"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1629DocumentationTextMustEndWithAPeriod.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1629DocumentationTextMustEndWithAPeriod.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1630DocumentationTextMustContainWhitespace">
             <summary>
             A section of the XML header documentation for a C# element does not contain any whitespace between words.
             </summary>
             <remarks>
             <para>This diagnostic is not implemented in StyleCopAnalyzers.</para>
            
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when part of the documentation does contain any whitespace between words.
             This can indicate poorly written or poorly formatted documentation. For example:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Joinsnames
             /// &lt;/summary&gt;
             /// &lt;param name="firstName"&gt;First&lt;/param&gt;
             /// &lt;param name="lastName"&gt;Last&lt;/param&gt;
             /// &lt;returns&gt;Name&lt;/returns&gt;
             public string JoinNames(string firstName, string lastName)
             {
                 ...
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1630DocumentationTextMustContainWhitespace.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1630DocumentationTextMustContainWhitespace"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1630DocumentationTextMustContainWhitespace.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1630DocumentationTextMustContainWhitespace.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1631DocumentationMustMeetCharacterPercentage">
             <summary>
             A section of the XML header documentation for a C# element does not contain enough alphabetic characters.
             </summary>
             <remarks>
             <para>This diagnostic is not implemented in StyleCopAnalyzers.</para>
            
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when part of the documentation does contain enough characters. This rule
             is calculated by counting the number of alphabetic characters and numbers within the documentation text, and
             comparing it against the number of symbols and other non-alphabetic characters. If the percentage of
             non-alphabetic characters is too high, this generally indicates poorly formatted documentation which will be
             difficult to read. For example, consider the follow summary documentation:</para>
            
             <code>
             /// &lt;summary&gt;
             /// @)$(*A name--------
             /// &lt;/summary&gt;
             public class Name
             {
                 ...
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1631DocumentationMustMeetCharacterPercentage.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1631DocumentationMustMeetCharacterPercentage"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1631DocumentationMustMeetCharacterPercentage.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1631DocumentationMustMeetCharacterPercentage.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1632DocumentationTextMustMeetMinimumCharacterLength">
             <summary>
             From StyleCop 4.5 this rule is disabled by default. A section of the XML header documentation for a C# element
             is too short.
             </summary>
             <remarks>
             <para>This diagnostic is not implemented in StyleCopAnalyzers.</para>
            
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when part of the documentation is too short. This can often indicate that
             the documentation is not descriptive. For example:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// A name
             /// &lt;/summary&gt;
             public class Name
             {
                 ...
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1632DocumentationTextMustMeetMinimumCharacterLength.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1632DocumentationTextMustMeetMinimumCharacterLength"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1632DocumentationTextMustMeetMinimumCharacterLength.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1632DocumentationTextMustMeetMinimumCharacterLength.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1642ConstructorSummaryDocumentationMustBeginWithStandardText">
             <summary>
             The XML documentation header for a C# constructor does not contain the appropriate summary text.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when the summary tag within the documentation header for a constructor
             does not begin with the proper text.</para>
            
             <para>The rule is intended to standardize the summary text for a constructor based on the access level of the
             constructor. The summary for a non-private instance constructor must begin with "Initializes a new instance of
             the {class name} class." For example, the following shows the constructor for the <c>Customer</c> class.</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Initializes a new instance of the Customer class.
             /// &lt;/summary&gt;
             public Customer()
             {
             }
             </code>
            
             <para>It is possible to embed other tags into the summary text. For example:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Initializes a new instance of the &lt;see cref="Customer"/&gt; class.
             /// &lt;/summary&gt;
             public Customer()
             {
             }
             </code>
            
             <para>If the class contains generic parameters, these can be annotated within the <c>cref</c> link using either
             of the following two formats:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Initializes a new instance of the &lt;see cref="Customer`1"/&gt; class.
             /// &lt;/summary&gt;
             public Customer()
             {
             }
            
             /// &lt;summary&gt;
             /// Initializes a new instance of the &lt;see cref="Customer{T}"/&gt; class.
             /// &lt;/summary&gt;
             public Customer()
             {
             }
             </code>
            
             <para>If the constructor is <see langword="static"/>, the summary text should begin with "Initializes static
             members of the {class name} class.” For example:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Initializes static members of the Customer class.
             /// &lt;/summary&gt;
             public static Customer()
             {
             }
             </code>
            
             <para>Private instance constructors must use the summary text "Prevents a default instance of the {class name}
             class from being created."</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Prevents a default instance of the Customer class from being created.
             /// &lt;/summary&gt;
             private Customer()
             {
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1642ConstructorSummaryDocumentationMustBeginWithStandardText.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1642ConstructorSummaryDocumentationMustBeginWithStandardText"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1642ConstructorSummaryDocumentationMustBeginWithStandardText.NonPrivateConstructorStandardText">
            <summary>
            Gets the standard text which is expected to appear at the beginning of the <c>&lt;summary&gt;</c>
            documentation for a non-private constructor.
            </summary>
            <value>
            The standard text which is expected to appear at the beginning of the <c>&lt;summary&gt;</c> documentation
            for a non-private constructor. This text appears before the name of the containing class, followed by a
            <c>&lt;see&gt;</c> element targeting the containing type, and finally followed by <c>class</c> or
            <c>struct</c> as appropriate for the containing type.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1642ConstructorSummaryDocumentationMustBeginWithStandardText.PrivateConstructorStandardText">
            <summary>
            Gets the standard text which is expected to appear at the beginning of the <c>&lt;summary&gt;</c>
            documentation for a private constructor.
            </summary>
            <remarks>
            <para>In addition to the format given in <see cref="P:StyleCop.Analyzers.DocumentationRules.SA1642ConstructorSummaryDocumentationMustBeginWithStandardText.PrivateConstructorStandardText"/>, a private constructor
            may choose to use <see cref="P:StyleCop.Analyzers.DocumentationRules.SA1642ConstructorSummaryDocumentationMustBeginWithStandardText.NonPrivateConstructorStandardText"/> instead. The code fix provided for this
            diagnostic uses <see cref="P:StyleCop.Analyzers.DocumentationRules.SA1642ConstructorSummaryDocumentationMustBeginWithStandardText.NonPrivateConstructorStandardText"/> by default, since this is generally a more
            accurate representation of a user's intent. In new code, <see langword="static"/> classes provide a
            superior alternative to private constructors for the purpose of declaring utility types that cannot be
            instantiated.</para>
            </remarks>
            <value>
            The standard text which is expected to appear at the beginning of the <c>&lt;summary&gt;</c> documentation
            for a private constructor. The first element appears before the name of the containing class, followed by a
            <c>&lt;see&gt;</c> element targeting the containing type, then by <c>class</c> or <c>struct</c> as
            appropriate for the containing type, and finally followed by the second element of this array.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1642ConstructorSummaryDocumentationMustBeginWithStandardText.StaticConstructorStandardText">
            <summary>
            Gets the standard text which is expected to appear at the beginning of the <c>&lt;summary&gt;</c>
            documentation for a static constructor.
            </summary>
            <value>
            The standard text which is expected to appear at the beginning of the <c>&lt;summary&gt;</c> documentation
            for a static constructor. The first element appears before the name of the containing class, followed by a
            <c>&lt;see&gt;</c> element targeting the containing type, and finally followed by <c>class</c> or
            <c>struct</c> as appropriate for the containing type.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1642ConstructorSummaryDocumentationMustBeginWithStandardText.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1642ConstructorSummaryDocumentationMustBeginWithStandardText.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1643DestructorSummaryDocumentationMustBeginWithStandardText">
             <summary>
             The XML documentation header for a C# finalizer does not contain the appropriate summary text.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when the summary tag within the documentation header for a finalizer does
             not begin with the proper text.</para>
            
             <para>The rule is intended to standardize the summary text for a finalizer. The summary for a finalizer must
             begin with "Finalizes an instance of the {class name} class." For example, the following shows the finalizer for
             the <c>Customer</c> class.</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Finalizes an instance of the Customer class.
             /// &lt;/summary&gt;
             ~Customer()
             {
             }
             </code>
            
             <para>It is possible to embed other tags into the summary text. For example:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Finalizes an instance of the &lt;see cref="Customer"/&gt; class.
             /// &lt;/summary&gt;
             ~Customer()
             {
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1643DestructorSummaryDocumentationMustBeginWithStandardText.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1643DestructorSummaryDocumentationMustBeginWithStandardText"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1643DestructorSummaryDocumentationMustBeginWithStandardText.DestructorStandardText">
            <summary>
            Gets the standard text which is expected to appear at the beginning of the <c>&lt;summary&gt;</c>
            documentation for a destructor.
            </summary>
            <value>
            A two-element array containing the standard text which is expected to appear at the beginning of the
            <c>&lt;summary&gt;</c> documentation for a destructor. The first element appears before the name of the
            containing class, followed by a <c>&lt;see&gt;</c> element targeting the containing type, and finally
            followed by the second element of this array.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1643DestructorSummaryDocumentationMustBeginWithStandardText.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1643DestructorSummaryDocumentationMustBeginWithStandardText.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1644DocumentationHeadersMustNotContainBlankLines">
             <summary>
             A section within the XML documentation header for a C# element contains blank lines.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>A violation of this rule occurs when the documentation header contains one or more blank lines within a
             section of documentation. For example:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Joins a first name and a last name together into a single string.
             ///
             /// Uses a simple form of string concatenation.
             /// &lt;/summary&gt;
             /// &lt;param name="firstName"&gt;The first name to join.&lt;/param&gt;
             /// &lt;param name="lastName"&gt;The last name to join.&lt;/param&gt;
             /// &lt;returns&gt;The joined names.&lt;/returns&gt;
             public string JoinNames(string firstName, string lastName)
             {
                 return firstName + " " + lastName;
             }
             </code>
            
             <para>Rather than inserting blank lines into the documentation, use the <c>&lt;para&gt;</c> tag to denote
             paragraphs. For example:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// &lt;para&gt;
             /// Joins a first name and a last name together into a single string.
             /// &lt;/para&gt;&lt;para&gt;
             /// Uses a simple form of string concatenation.
             /// &lt;/para&gt;
             /// &lt;/summary&gt;
             /// &lt;param name="firstName"&gt;The first name to join.&lt;/param&gt;
             /// &lt;param name="lastName"&gt;The last name to join.&lt;/param&gt;
             /// &lt;returns&gt;The joined names.&lt;/returns&gt;
             public string JoinNames(string firstName, string lastName)
             {
                 return firstName + " " + lastName;
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1644DocumentationHeadersMustNotContainBlankLines.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1644DocumentationHeadersMustNotContainBlankLines"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1644DocumentationHeadersMustNotContainBlankLines.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1644DocumentationHeadersMustNotContainBlankLines.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1645IncludedDocumentationFileDoesNotExist">
             <summary>
             An included XML documentation file does not exist.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>As an alternative to authoring documentation directly within the code file, it is possible to place
             documentation for multiple elements within a separate XML file, and then reference a section of that file within
             an element's documentation header. This causes the compiler to import the documentation for that element from
             the included document. For example:</para>
            
             <code language="csharp">
             /// &lt;include file="IncludedDocumentation.xml" path="root/EnabledMethodDocs" /&gt;
             public bool Enabled(bool true)
             {
             }
             </code>
            
             <para>A violation of this rule occurs when the included file does not exist at the given location, or cannot be
             loaded.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1645IncludedDocumentationFileDoesNotExist.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1645IncludedDocumentationFileDoesNotExist"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1645IncludedDocumentationFileDoesNotExist.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1645IncludedDocumentationFileDoesNotExist.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1646IncludedDocumentationXPathDoesNotExist">
             <summary>
             An included XML documentation link contains an invalid path.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>As an alternative to authoring documentation directly within the code file, it is possible to place
             documentation for multiple elements within a separate XML file, and then reference a section of that file within
             an element's documentation header. This causes the compiler to import the documentation for that element from
             the included document. For example:</para>
            
             <code language="csharp">
             /// &lt;include file="IncludedDocumentation.xml" path="root/EnabledMethodDocs" /&gt;
             public bool Enabled(bool true)
             {
             }
             </code>
            
             <para>A violation of this rule occurs when the path attribute does not link to a valid path within the included
             documentation file.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1646IncludedDocumentationXPathDoesNotExist.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1646IncludedDocumentationXPathDoesNotExist"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1646IncludedDocumentationXPathDoesNotExist.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1646IncludedDocumentationXPathDoesNotExist.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1647IncludeNodeDoesNotContainValidFileAndPath">
             <summary>
             An <c>include</c> tag within an XML documentation header does not contain valid file and path attribute.
             </summary>
             <remarks>
             <para>C# syntax provides a mechanism for inserting documentation for classes and elements directly into the
             code, through the use of XML documentation headers. For an introduction to these headers and a description of
             the header syntax, see the following article:
             <see href="http://msdn.microsoft.com/en-us/magazine/cc302121.aspx">XML Comments Let You Build Documentation
             Directly From Your Visual Studio .NET Source Files</see>.</para>
            
             <para>As an alternative to authoring documentation directly within the code file, it is possible to place
             documentation for multiple elements within a separate XML file, and then reference a section of that file within
             an element's documentation header. This causes the compiler to import the documentation for that element from
             the included document. For example:</para>
            
             <code language="csharp">
             /// &lt;include file="IncludedDocumentation.xml" path="root/EnabledMethodDocs" /&gt;
             public bool Enabled(bool true)
             {
             }
             </code>
            
             <para>A violation of this rule occurs when the include tag is missing a file or path attribute, or contains an
             improperly formatted file or path attribute.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1647IncludeNodeDoesNotContainValidFileAndPath.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1647IncludeNodeDoesNotContainValidFileAndPath"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1647IncludeNodeDoesNotContainValidFileAndPath.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1647IncludeNodeDoesNotContainValidFileAndPath.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1648InheritDocMustBeUsedWithInheritingClass">
            <summary>
            <c>&lt;inheritdoc&gt;</c> has been used on an element that doesn't inherit from a base class or implement an
            interface.
            </summary>
            <seealso href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1648.md">SA1648</seealso>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1648InheritDocMustBeUsedWithInheritingClass.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1648InheritDocMustBeUsedWithInheritingClass"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1648InheritDocMustBeUsedWithInheritingClass.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1648InheritDocMustBeUsedWithInheritingClass.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1649FileNameMustMatchTypeName">
            <summary>
            The name of a C# code file does not match the first type declared in the file. For generics
            that are defined as Class1&lt;T&gt; the name of the file needs to be Class1{T}.cs or Class1`1
            depending on the fileNamingConvention setting.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1649FileNameMustMatchTypeName.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1649FileNameMustMatchTypeName"/>
            analyzer.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1649FileNameMustMatchTypeName.ExpectedFileNameKey">
            <summary>
            The key used for passing the expected file name to the code fix provider.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1649FileNameMustMatchTypeName.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1649FileNameMustMatchTypeName.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1650ElementDocumentationMustBeSpelledCorrectly">
             <summary>
             The element documentation for the element contains one or more spelling mistakes or unrecognized words.
             </summary>
             <remarks>
             <para>This diagnostic is not implemented in StyleCopAnalyzers.</para>
            
             <para>A violation of this rule occurs when the element documentation contains spelling mistakes:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Joinsnames
             /// &lt;/summary&gt;
             /// &lt;param name="firstName"&gt;The first name.&lt;/param&gt;
             /// &lt;param name="lastName"&gt;The last name.&lt;/param&gt;
             /// &lt;returns&gt;Name&lt;/returns&gt;
             public string JoinNames(string firstName, string lastName)
             {
                 ...
             }
             </code>
            
             <para>The spelling is checked using the culture specified in the Settings. StyleCop file (and en-US by
             default).</para>
            
             <para>In this example the word Joinsnames in the summary element is misspelled. Either correct the spelling,
             insert any C# names in <c>&lt;c&gt;</c> <c>&lt;/c&gt;</c> elements, suppress the violation, or add the
             Joinsnames to a CustomDictionary.xml file.</para>
            
             <list type="bullet">
             <item>CustomDictionary.xml files can contain words that the spelling checker does not normally recognize.</item>
             <item>The CustomDictionary.xml file should be placed in the same folder as the StyleCop.dll and the Rules. That
             folder (and all subfolders) are checked for the dictionary files.</item>
             <item>StyleCop loads CustomDictionary.xml, CustomDictionary.en-GB.xml and then CustomDictionary.en.xml (where
             en-GB is the culture specified in the Settings.StyleCop file).</item>
             <item>StyleCop also loads custom.dic, custom.en-GB.dic and then custom.en.dic (where en-GB is the culture
             specified in the Settings.StyleCop file).</item>
             <item>Recognized words can also be added to the Settings.StyleCop file using the Settings Editor on the spelling
             tab.</item>
             <item>Attribute values in the documentation xml of the element are not checked for spelling.</item>
             <item>Any text inside <c> </c> or <code> </code> elements is also ignored.</item>
             <item>Any text starting with and ending with '$' or starting and ending with '$$' is also ignored. i.e.
             $$(thtp kthpo kthpk)$$.</item>
             </list>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1650ElementDocumentationMustBeSpelledCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1650ElementDocumentationMustBeSpelledCorrectly"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1650ElementDocumentationMustBeSpelledCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1650ElementDocumentationMustBeSpelledCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.SA1651DoNotUsePlaceholderElements">
             <summary>
             The documentation for the element contains one or more &lt;placeholder&gt; elements.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the element documentation contains &lt;placeholder&gt;
             elements:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// This method &lt;placeholder&gt;performs some operation&lt;/placeholder&gt;.
             /// &lt;/summary&gt;
             public void SomeOperation()
             {
                 ...
             }
             </code>
            
             <para>Placeholder elements should be reviewed and removed from documentation.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.SA1651DoNotUsePlaceholderElements.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1651DoNotUsePlaceholderElements"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.DocumentationRules.SA1651DoNotUsePlaceholderElements.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.SA1651DoNotUsePlaceholderElements.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.StandardTextDiagnosticBase">
            <summary>
            A base class for diagnostics <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1642ConstructorSummaryDocumentationMustBeginWithStandardText"/> and <see cref="T:StyleCop.Analyzers.DocumentationRules.SA1643DestructorSummaryDocumentationMustBeginWithStandardText"/> to share common code.
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.DocumentationRules.StandardTextDiagnosticBase.MatchResult">
            <summary>
            Describes the result of matching a summary element to a specific desired wording.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.StandardTextDiagnosticBase.MatchResult.Unknown">
            <summary>
            The analysis could not be completed due to errors in the syntax tree or a comment structure which was
            not accounted for.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.StandardTextDiagnosticBase.MatchResult.None">
            <summary>
            No complete or partial match was found.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.StandardTextDiagnosticBase.MatchResult.InvalidSeeTag">
            <summary>
            A standard text was found but the see element was incorrect.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.DocumentationRules.StandardTextDiagnosticBase.MatchResult.FoundMatch">
            <summary>
            A match to the expected text was found.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.DocumentationRules.StandardTextDiagnosticBase.HandleDeclaration(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticDescriptor)">
            <summary>
            Analyzes a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax"/> node. If it has a summary it is checked if the text starts with &quot;[firstTextPart]&lt;see cref=&quot;[className]&quot;/&gt;[secondTextPart]&quot;.
            </summary>
            <param name="context">The <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext"/> of this analysis.</param>
            <param name="firstTextPart">The first part of the standard text.</param>
            <param name="secondTextPart">The second part of the standard text.</param>
            <param name="diagnosticDescriptor">The diagnostic to report for violations, or <see langword="null"/> to not report violations.</param>
            <returns>A <see cref="T:StyleCop.Analyzers.DocumentationRules.StandardTextDiagnosticBase.MatchResult"/> describing the result of the analysis.</returns>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.AccessLevel">
            <summary>
            Describes an element's access level
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Helpers.AccessLevel.NotSpecified">
            <summary>No access level specified.</summary>
        </member>
        <member name="F:StyleCop.Analyzers.Helpers.AccessLevel.Private">
            <summary>Private access.</summary>
        </member>
        <member name="F:StyleCop.Analyzers.Helpers.AccessLevel.Protected">
            <summary>Protected access.</summary>
        </member>
        <member name="F:StyleCop.Analyzers.Helpers.AccessLevel.ProtectedInternal">
            <summary>Protected internal access.</summary>
        </member>
        <member name="F:StyleCop.Analyzers.Helpers.AccessLevel.Internal">
            <summary>Internal access.</summary>
        </member>
        <member name="F:StyleCop.Analyzers.Helpers.AccessLevel.Public">
            <summary>Public access.</summary>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.AccessLevelHelper">
            <summary>
            Contains helper methods for determining an element's access level.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.AccessLevelHelper.GetAccessLevel(Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>Determines the access level for the given <paramref name="modifiers"/>.</summary>
            <param name="modifiers">The modifiers.</param>
            <returns>A <see cref="T:StyleCop.Analyzers.Helpers.AccessLevel"/> value representing the access level.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.AccessLevelHelper.GetName(StyleCop.Analyzers.Helpers.AccessLevel)">
            <summary>Gets the name for a given access level.</summary>
            <param name="accessLevel">The access level.</param>
            <returns>The name for a given access level.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.AccessLevelHelper.ToAccessibility(StyleCop.Analyzers.Helpers.AccessLevel)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Accessibility"/> corresponding to a specified <see cref="T:StyleCop.Analyzers.Helpers.AccessLevel"/> value.
            </summary>
            <param name="accessLevel">The <see cref="T:StyleCop.Analyzers.Helpers.AccessLevel"/> to convert.</param>
            <returns>
            The <see cref="T:Microsoft.CodeAnalysis.Accessibility"/> associated with the specified <see cref="T:StyleCop.Analyzers.Helpers.AccessLevel"/> value.
            </returns>
            <exception cref="T:System.ArgumentException">
            If <paramref name="accessLevel"/> is <see cref="F:StyleCop.Analyzers.Helpers.AccessLevel.NotSpecified"/> or does not map directly to any
            <see cref="T:Microsoft.CodeAnalysis.Accessibility"/> value.
            </exception>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.DeclarationModifiersHelper.AddModifier``1(Microsoft.CodeAnalysis.SyntaxTokenList,``0@,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Adds a modifier token for <paramref name="modifierKeyword"/> to the beginning of
            <paramref name="modifiers"/>. The trivia for the new modifier and the trivia for the token that follows it
            are updated to ensure that the new modifier is placed immediately before the syntax token that follows it,
            separated by exactly one space.
            </summary>
            <typeparam name="T">The type of syntax node which follows the modifier list.</typeparam>
            <param name="modifiers">The existing modifiers. This may be empty if no modifiers are present.</param>
            <param name="leadingTriviaNode">The syntax node which follows the modifiers. The trivia for this node is
            updated if (and only if) the existing <paramref name="modifiers"/> list is empty.</param>
            <param name="modifierKeyword">The modifier keyword to add.</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> representing the original modifiers (if any) with the addition of a
            modifier of the specified <paramref name="modifierKeyword"/> at the beginning of the list.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.DeclarationModifiersHelper.AddModifier(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Adds a modifier token for <paramref name="modifierKeyword"/> to the beginning of
            <paramref name="modifiers"/>. The trivia for the new modifier and the trivia for the token that follows it
            are updated to ensure that the new modifier is placed immediately before the syntax token that follows it,
            separated by exactly one space.
            </summary>
            <param name="modifiers">The existing modifiers. This may be empty if no modifiers are present.</param>
            <param name="leadingTriviaToken">The syntax token which follows the modifiers. The trivia for this token is
            updated if (and only if) the existing <paramref name="modifiers"/> list is empty.</param>
            <param name="modifierKeyword">The modifier keyword to add.</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> representing the original modifiers (if any) with the addition of a
            modifier of the specified <paramref name="modifierKeyword"/> at the beginning of the list.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.DeclarationModifiersHelper.AddModifiers(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken@,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CSharp.SyntaxKind})">
            <summary>
            Adds a number of modifier tokens for <paramref name="modifierKeywords"/> to the beginning of
            <paramref name="modifiers"/>. The trivia for the new modifier and the trivia for the token that follows it
            are updated to ensure that the new modifier is placed immediately before the syntax token that follows it,
            separated by exactly one space.
            </summary>
            <param name="modifiers">The existing modifiers. This may be empty if no modifiers are present.</param>
            <param name="leadingTriviaToken">The syntax token which follows the modifiers. The trivia for this token is
            updated if (and only if) the existing <paramref name="modifiers"/> list is empty.</param>
            <param name="modifierKeywords">The modifier keywords to add.</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> representing the original modifiers (if any) with the addition of a
            modifier of the specified <paramref name="modifierKeywords"/> at the beginning of the list.</returns>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.DiagnosticOptionsHelper">
            <summary>
            Provides helper methods to work with diagnostics options.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.DiagnosticOptionsHelper.IsAnalyzerSuppressed(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.String)">
            <summary>
            Determines if the diagnostic identified by the given identifier is currently suppressed.
            </summary>
            <param name="context">The context that will be used to determine if the diagnostic is currently suppressed.</param>
            <param name="diagnosticId">The diagnostic identifier to check.</param>
            <returns>True if the diagnostic is currently suppressed.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.DiagnosticOptionsHelper.IsAnalyzerSuppressed(Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext,System.String)">
            <summary>
            Determines if the diagnostic identified by the given identifier is currently suppressed.
            </summary>
            <param name="context">The context that will be used to determine if the diagnostic is currently suppressed.</param>
            <param name="diagnosticId">The diagnostic identifier to check.</param>
            <returns>True if the diagnostic is currently suppressed.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.DiagnosticOptionsHelper.IsAnalyzerSuppressed(Microsoft.CodeAnalysis.Compilation,System.String)">
            <summary>
            Determines if the diagnostic identified by the given identifier is currently suppressed.
            </summary>
            <param name="compilation">The compilation that will be used to determine if the diagnostic is currently suppressed.</param>
            <param name="diagnosticId">The diagnostic identifier to check.</param>
            <returns>True if the diagnostic is currently suppressed.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.DiagnosticOptionsHelper.IsAnalyzerSuppressed(Microsoft.CodeAnalysis.CompilationOptions,System.String)">
            <summary>
            Determines if the diagnostic identified by the given identifier is currently suppressed.
            </summary>
            <param name="compilationOptions">The compilation options that will be used to determine if the diagnostic is currently suppressed.</param>
            <param name="diagnosticId">The diagnostic identifier to check.</param>
            <returns>True if the diagnostic is currently suppressed.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.DiagnosticOptionsHelper.GetDocumentationMode(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext)">
            <summary>
            Gets the effective <see cref="T:Microsoft.CodeAnalysis.DocumentationMode"/> used when parsing the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> containing
            the specified context.
            </summary>
            <param name="context">The analysis context.</param>
            <returns>
            <para>The <see cref="T:Microsoft.CodeAnalysis.DocumentationMode"/> of the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> containing the context.</para>
            <para>-or-</para>
            <para><see cref="F:Microsoft.CodeAnalysis.DocumentationMode.Diagnose"/>, if the documentation mode could not be determined.</para>
            </returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.DocumentationCommentExtensions.AdjustDocumentationCommentNewLineTrivia``1(``0)">
            <summary>
            Adjust the leading and trailing trivia associated with <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlTextLiteralNewLineToken"/>
            tokens to ensure the formatter properly indents the exterior trivia.
            </summary>
            <typeparam name="T">The type of syntax node.</typeparam>
            <param name="node">The syntax node to adjust tokens.</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> equivalent to the input <paramref name="node"/>, adjusted by moving any
            trailing trivia from <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlTextLiteralNewLineToken"/> tokens to be leading trivia of the
            following token.</returns>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.FileHeader">
            <summary>
            Class containing the parsed file header information.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.FileHeader.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.Helpers.FileHeader"/> class.
            </summary>
            <param name="copyrightText">The copyright string, as parsed from the header.</param>
            <param name="fileHeaderStart">The offset within the file at which the header started.</param>
            <param name="fileHeaderEnd">The offset within the file at which the header ended.</param>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.FileHeader.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:StyleCop.Analyzers.Helpers.FileHeader"/> class from being created.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.FileHeader.MissingFileHeader">
            <summary>
            Gets a <see cref="T:StyleCop.Analyzers.Helpers.FileHeader"/> instance representing a missing file header.
            </summary>
            <value>
            A <see cref="T:StyleCop.Analyzers.Helpers.FileHeader"/> instance representing a missing file header.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.FileHeader.IsMissing">
            <summary>
            Gets a value indicating whether the file header is missing.
            </summary>
            <value>
            True if the file header is missing.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.FileHeader.CopyrightText">
            <summary>
            Gets the copyright text, as parsed from the header.
            </summary>
            <value>
            The copyright text, as parsed from the header.
            </value>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.FileHeader.GetLocation(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets the location representing the start of the file header.
            </summary>
            <param name="syntaxTree">The syntax tree to use for generating the location.</param>
            <returns>The location representing the start of the file header.</returns>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.FileHeaderHelpers">
            <summary>
            Helper class used for working with file headers
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.FileHeaderHelpers.ParseFileHeader(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Parses a comment-only file header.
            </summary>
            <param name="root">The root of the syntax tree.</param>
            <returns>The copyright string, as parsed from the file header.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.FileHeaderHelpers.ParseXmlFileHeader(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Parses an XML-based file header.
            </summary>
            <param name="root">The root of the syntax tree.</param>
            <returns>The parsed file header.</returns>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.HelpersResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.HelpersResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.HelpersResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.HelpersResources.FixAllOccurrencesOfDiagnostic">
            <summary>
              Looks up a localized string similar to Fix all &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.HelpersResources.FixAllOccurrencesOfDiagnosticInScope">
            <summary>
              Looks up a localized string similar to Fix all &apos;{0}&apos; in &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.HelpersResources.FixAllOccurrencesOfDiagnosticInSolution">
            <summary>
              Looks up a localized string similar to Fix all &apos;{0}&apos; in Solution.
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.LocationHelpers">
            <summary>
            Provides helper methods for working with source file locations.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.LocationHelpers.GetLineSpan(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets the location in terms of path, line and column for a given token.
            </summary>
            <param name="token">The token to use.</param>
            <returns>The location in terms of path, line and column for a given token.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.LocationHelpers.GetLineSpan(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the location in terms of path, line and column for a given node.
            </summary>
            <param name="node">The node to use.</param>
            <returns>The location in terms of path, line and column for a given node.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.LocationHelpers.GetLineSpan(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Gets the location in terms of path, line and column for a given trivia.
            </summary>
            <param name="trivia">The trivia to use.</param>
            <returns>The location in terms of path, line and column for a given trivia.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.LocationHelpers.GetLineSpan(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Gets the location in terms of path, line and column for a given node or token.
            </summary>
            <param name="nodeOrToken">The trivia to use.</param>
            <returns>The location in terms of path, line and column for a given node or token.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.LocationHelpers.GetLine(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets the line on which the given token occurs.
            </summary>
            <param name="token">The token to use.</param>
            <returns>The line on which the given token occurs.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.LocationHelpers.GetLine(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the line on which the given node occurs.
            </summary>
            <param name="node">The node to use.</param>
            <returns>The line on which the given node occurs.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.LocationHelpers.GetLine(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Gets the line on which the given trivia occurs.
            </summary>
            <param name="trivia">The trivia to use.</param>
            <returns>The line on which the given trivia occurs.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.LocationHelpers.GetEndLine(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets the end line of the given token.
            </summary>
            <param name="token">The token to use.</param>
            <returns>The line on which the given token ends.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.LocationHelpers.GetEndLine(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the end line of the given node.
            </summary>
            <param name="node">The node to use.</param>
            <returns>The line on which the given node ends.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.LocationHelpers.GetEndLine(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Gets the end line of the given trivia.
            </summary>
            <param name="trivia">The trivia to use.</param>
            <returns>The line on which the given trivia ends.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.LocationHelpers.SpansMultipleLines(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Get a value indicating whether the given node span multiple source text lines.
            </summary>
            <param name="node">The node to check.</param>
            <returns>True, if the node spans multiple source text lines.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.LocationHelpers.SpansMultipleLines(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Gets a value indicating whether the given trivia span multiple source text lines.
            </summary>
            <param name="trivia">The trivia to check.</param>
            <returns>
            <see langword="true"/> if the trivia spans multiple source text lines; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.MemberOrderHelper">
            <summary>
            Helper for dealing with member priority.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.MemberOrderHelper.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Collections.Immutable.ImmutableArray{StyleCop.Analyzers.Settings.ObjectModel.OrderingTrait})">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.Helpers.MemberOrderHelper"/> struct.
            </summary>
            <param name="member">The member to wrap.</param>
            <param name="elementOrder">The element ordering traits.</param>
        </member>
        <member name="F:StyleCop.Analyzers.Helpers.MemberOrderHelper.ModifierFlags.None">
            <summary>
            No modifiers
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Helpers.MemberOrderHelper.ModifierFlags.Readonly">
            <summary>
            Readonly modifier
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Helpers.MemberOrderHelper.ModifierFlags.Static">
            <summary>
            Static modifier
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Helpers.MemberOrderHelper.ModifierFlags.Const">
            <summary>
            Const modifier
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.MemberOrderHelper.Member">
            <summary>
            Gets the wrapped member.
            </summary>
            <value>
            The wrapped member.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.MemberOrderHelper.Priority">
            <summary>
            Gets the priority for this member.
            </summary>
            <value>
            The priority for this member.
            </value>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.NamedTypeHelpers.IsImplementingAnInterfaceMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns whether or not a member is implementing an interface member.
            </summary>
            <remarks>
            This method does only check the interfaces the containing type is implementing directly.
            If a derived class is implementing an interface and this member is required for it
            this method will still return false.
            </remarks>
            <param name="memberSymbol">The member symbol that should be analyzed.</param>
            <returns>true if the member is implementing an interface member, otherwise false.</returns>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.NameSyntaxHelpers">
            <summary>
            Class containing the extension methods for the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax"/> class.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.NameSyntaxHelpers.ToNormalizedString(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>
            Gets the name contained in the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax"/>, including the alias prefix (if any).
            </summary>
            <param name="nameSyntax">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax"/> from which the name will be extracted.</param>
            <returns>The name contained in the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax"/>, including its alias (if any).</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.NameSyntaxHelpers.ToUnaliasedString(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>
            Gets the name contained in the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax"/>, without an alias prefix.
            </summary>
            <param name="nameSyntax">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax"/> from which the name will be extracted.</param>
            <returns>The name contained in the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax"/>, with its alias removed (if any).</returns>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.ObjectPools.ObjectPool`1">
             <summary>
             Generic implementation of object pooling pattern with predefined pool size limit. The main
             purpose is that limited number of frequently used objects can be kept in the pool for
             further recycling.
            
             Notes:
             1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
                is no space in the pool, extra returned objects will be dropped.
            
             2) it is implied that if object was obtained from a pool, the caller will return it back in
                a relatively short time. Keeping checked out objects for long durations is ok, but
                reduces usefulness of pooling. Just new up your own.
            
             Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice.
             Rationale:
                If there is no intent for reusing the object, do not use pool - just use "new".
             </summary>
             <typeparam name="T">The type of the objects in this cache.</typeparam>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.ObjectPools.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically
            reducing how far we will typically search.
            </remarks>
            <returns>A (possibly) cached instance of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.ObjectPools.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically
            reducing how far we will typically search in Allocate.
            </remarks>
            <param name="obj">The object to free.</param>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.ObjectPools.PooledObject`1">
            <summary>
            this is RAII object to automatically release pooled object when its owning pool
            </summary>
            <typeparam name="T">The type of the pooled object.</typeparam>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.ObjectPools.SharedPools">
             <summary>
             Shared object pool for roslyn
            
             Use this shared pool if only concern is reducing object allocations.
             if perf of an object pool itself is also a concern, use ObjectPool directly.
            
             For example, if you want to create a million of small objects within a second,
             use the ObjectPool directly. it should have much less overhead than using this.
             </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.ObjectPools.SharedPools.BigDefault``1">
            <summary>
            pool that uses default constructor with 100 elements pooled
            </summary>
            <typeparam name="T">The type of the object pool.</typeparam>
            <returns>A default big object pool.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.ObjectPools.SharedPools.Default``1">
            <summary>
            pool that uses default constructor with 20 elements pooled
            </summary>
            <typeparam name="T">The type of the object pool.</typeparam>
            <returns>A default object pool.</returns>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.Requires">
            <summary>
            This class contains helper methods for argument validation.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.Requires.NotNull``1(``0,System.String)">
            <summary>
            Validates that an argument is not null.
            </summary>
            <typeparam name="T">The parameter type.</typeparam>
            <param name="argument">The argument value.</param>
            <param name="parameterName">The name of the parameter.</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="argument"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.SpacingExtensions.WithoutTrivia(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Removes the leading and trailing trivia associated with a syntax token.
            </summary>
            <param name="token">The syntax token to remove trivia from.</param>
            <returns>A copy of the input syntax token with leading and trailing trivia removed.</returns>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.SyntaxKinds.BaseTypeDeclaration">
            <summary>
            Gets a collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax"/>.
            </summary>
            <value>
            A collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax"/>.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.SyntaxKinds.TypeDeclaration">
            <summary>
            Gets a collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax"/>.
            </summary>
            <value>
            A collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax"/>.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.SyntaxKinds.BaseFieldDeclaration">
            <summary>
            Gets a collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax"/>.
            </summary>
            <value>
            A collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax"/>.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.SyntaxKinds.BaseMethodDeclaration">
            <summary>
            Gets a collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax"/>.
            </summary>
            <value>
            A collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax"/>.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.SyntaxKinds.BasePropertyDeclaration">
            <summary>
            Gets a collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax"/>.
            </summary>
            <value>
            A collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax"/>.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.SyntaxKinds.AccessorDeclaration">
            <summary>
            Gets a collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as an
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax"/>.
            </summary>
            <value>
            A collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as an
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax"/>.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.SyntaxKinds.InitializerExpression">
            <summary>
            Gets a collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as an
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax"/>.
            </summary>
            <value>
            A collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as an
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax"/>.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.SyntaxKinds.DocumentationComment">
            <summary>
            Gets a collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax"/>.
            </summary>
            <value>
            A collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax"/>.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.SyntaxKinds.ConstructorInitializer">
            <summary>
            Gets a collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax"/>.
            </summary>
            <value>
            A collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax"/>.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.SyntaxKinds.LambdaExpression">
            <summary>
            Gets a collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax"/>.
            </summary>
            <value>
            A collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax"/>.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.SyntaxKinds.AnonymousFunctionExpression">
            <summary>
            Gets a collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as an
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax"/>.
            </summary>
            <value>
            A collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as an
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax"/>.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.SyntaxKinds.SimpleName">
            <summary>
            Gets a collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax"/>.
            </summary>
            <value>
            A collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax"/>.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.SyntaxKinds.BaseParameterList">
            <summary>
            Gets a collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax"/>.
            </summary>
            <value>
            A collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax"/>.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.SyntaxKinds.BaseArgumentList">
            <summary>
            Gets a collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax"/>.
            </summary>
            <value>
            A collection of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> values which appear in the syntax tree as a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax"/>.
            </value>
        </member>
        <member name="F:StyleCop.Analyzers.Helpers.SyntaxTreeHelpers.usingAliasCache">
            <summary>
            A cache of the result of computing whether a document has using alias directives.
            </summary>
            <remarks>
            This allows many analyzers that run on every token in the file to avoid checking
            the same state in the document repeatedly.
            </remarks>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.SyntaxTreeHelpers.IsWhitespaceOnly(Microsoft.CodeAnalysis.SyntaxTree,System.Threading.CancellationToken)">
            <summary>
            Checks if a given <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> only contains whitespace. We don't want to analyze empty files.
            </summary>
            <param name="tree">The syntax tree to examine.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> that the task will observe.</param>
            <returns>
            <see langword="true"/> if <paramref name="tree"/> only contains whitespace; otherwise,
            <see langword="false"/>.
            </returns>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.TokenHelper">
            <summary>
            Provides helper methods to work with token.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TokenHelper.IsFirstInLine(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets a value indicating whether the <paramref name="token"/> is first in line.
            </summary>
            <param name="token">The token to process.</param>
            <returns>true if token is first in line, otherwise false.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TokenHelper.IsLastInLine(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets a value indicating whether the <paramref name="token"/> is last in line.
            </summary>
            <param name="token">The token to process.</param>
            <returns>true if token is last in line, otherwise false.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TokenHelper.IsPrecededByWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
            <summary>
            Gets a value indicating whether the <paramref name="token"/> is preceded by a whitespace.
            </summary>
            <param name="token">The token to process.</param>
            <param name="cancellationToken">The cancellation token that the operation will observe.</param>
            <returns>true if token is preceded by a whitespace, otherwise false.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TokenHelper.IsOnlyPrecededByWhitespaceInLine(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets a value indicating whether the <paramref name="token"/> is the first token in a line and it is only preceded by whitespace.
            </summary>
            <param name="token">The token to process.</param>
            <returns>true if the token is the first token in a line and it is only preceded by whitespace.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TokenHelper.IsFollowedByWhitespace(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets a value indicating whether the <paramref name="token"/> is followed by a whitespace.
            </summary>
            <param name="token">The token to process.</param>
            <returns>true if token is followed by a whitespace, otherwise false.</returns>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.TriviaHelper">
            <summary>
            Provides helper methods to work with trivia (lists).
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TriviaHelper.IndexOfFirstNonWhitespaceTrivia``1(``0,System.Boolean)">
            <summary>
            Returns the index of the first non-whitespace trivia in the given trivia list.
            </summary>
            <param name="triviaList">The trivia list to process.</param>
            <param name="endOfLineIsWhitespace"><see langword="true"/> to treat <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia"/>
            as whitespace; otherwise, <see langword="false"/>.</param>
            <typeparam name="T">The type of the trivia list.</typeparam>
            <returns>The index where the non-whitespace starts, or -1 if there is no non-whitespace trivia.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TriviaHelper.IndexOfFirstNonBlankLineTrivia``1(``0)">
            <summary>
            Returns the index of the first trivia that is not part of a blank line.
            </summary>
            <param name="triviaList">The trivia list to process.</param>
            <typeparam name="T">The type of the trivia list.</typeparam>
            <returns>The index of the first trivia that is not part of a blank line, or -1 if there is no such trivia.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TriviaHelper.IndexOfTrailingWhitespace``1(``0)">
            <summary>
            Returns the index into the trivia list where the trailing whitespace starts.
            </summary>
            <param name="triviaList">The trivia list to process.</param>
            <typeparam name="T">The type of the trivia list.</typeparam>
            <returns>The index where the trailing whitespace starts, or -1 if there is no trailing whitespace.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TriviaHelper.RemoveRange(Microsoft.CodeAnalysis.SyntaxTriviaList,System.Int32,System.Int32)">
            <summary>
            Removes a range of elements from the <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/>.
            </summary>
            <param name="list">The list to remove elements from.</param>
            <param name="index">The zero-based starting index of the range of elements to remove.</param>
            <param name="count">The number of elements to remove.</param>
            <returns>A copy of <paramref name="list"/> with the specified range of elements removed.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>If <paramref name="index"/> is less than 0.</para>
            <para>-or-</para>
            <para>If <paramref name="count"/> is less than 0.</para>
            </exception>
            <exception cref="T:System.ArgumentException">
            <para>If <paramref name="index"/> and <paramref name="count"/> do not denote a valid range of elements in
            the <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/>.</para>
            </exception>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TriviaHelper.LastIndexOf(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Returns the index of the last trivia of a specified kind in the trivia list.
            </summary>
            <param name="list">The trivia list.</param>
            <param name="kind">The syntax kind to find.</param>
            <returns>
            <para>The non-negative index of the last trivia which matches <paramref name="kind"/>.</para>
            <para>-or-</para>
            <para>-1, if the list did not contain any matching trivia.</para>
            </returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TriviaHelper.WithoutTrailingWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Strips all trailing whitespace trivia from the trivia list until a non-whitespace trivia is encountered.
            </summary>
            <param name="triviaList">The trivia list to strip of its trailing whitespace.</param>
            <returns>The modified triviaList.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TriviaHelper.WithoutLeadingWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.Boolean)">
            <summary>
            Strips all leading whitespace trivia from the trivia list until a non-whitespace trivia is encountered.
            </summary>
            <param name="triviaList">The trivia list to strip of its leading whitespace.</param>
            <param name="endOfLineIsWhitespace"><see langword="true"/> to treat <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia"/>
            as whitespace; otherwise, <see langword="false"/>.</param>
            <returns>The modified triviaList.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TriviaHelper.GetContainingTriviaList(Microsoft.CodeAnalysis.SyntaxTrivia,System.Int32@)">
            <summary>
            <para>
            Builds a trivia list that contains the given trivia.
            </para>
            <para>
            This method combines the trailing and leading trivia of the tokens between which the given trivia is defined.
            </para>
            </summary>
            <param name="trivia">The trivia to create the list from.</param>
            <param name="triviaIndex">The index of the trivia in the created trivia list.</param>
            <returns>The created trivia list.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TriviaHelper.MergeTriviaLists(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Merges the given trivia lists into a new single trivia list.
            </summary>
            <param name="list1">The first part of the new list.</param>
            <param name="list2">The second part of the new list.</param>
            <returns>The merged trivia list.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TriviaHelper.IsPrecededByBlankLines(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines if the given token is immediately preceded by blank lines. Leading whitespace on the same line as
            the token is ignored.
            </summary>
            <param name="token">The token to check for immediately preceding blank lines.</param>
            <returns>
            <see langword="true"/> if the token is immediately preceded by blank lines; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.TriviaHelper.WithoutLeadingBlankLines(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Strips all leading blank lines from the given token.
            </summary>
            <param name="token">The token to strip.</param>
            <returns>A new token without leading blank lines.</returns>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.TriviaHelper.DualTriviaListHelper">
            <summary>
            Helper class that merges two SyntaxTriviaLists with (hopefully) the lowest possible performance penalty.
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.UsingDirectiveSyntaxHelpers">
            <summary>
            Class containing the extension methods for the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax"/> class.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.UsingDirectiveSyntaxHelpers.IsSystemUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)">
            <summary>
            Check if <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax"/> is system using directive.
            </summary>
            <param name="usingDirective">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax"/> that will be checked.</param>
            <returns>Return true if the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax"/>is system using directive, otherwise false.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.UsingDirectiveSyntaxHelpers.IsPrecededByPreprocessorDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)">
            <summary>
            Check if <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax"/> is preceded by a preprocessor directive.
            </summary>
            <param name="usingDirective">The using directive.</param>
            <returns>True if the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax"/> is preceded by a preprocessor directive, otherwise false.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.UsingDirectiveSyntaxHelpers.HasNamespaceAliasQualifier(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)">
            <summary>
            Check if the name of using directive contains a namespace alias qualifier.
            </summary>
            <param name="usingDirective">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax"/> that will be checked.</param>
            <returns>
            <see langword="true"/> if the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax"/> contains a namespace alias qualifier;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.XmlCommentHelper">
            <summary>
            Provides helper methods to work with XML comments
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Helpers.XmlCommentHelper.PlaceholderTag">
            <summary>
            The &lt;placeholder&gt; tag is a Sandcastle Help File Builder extension to the standard XML documentation
            comment tags, and is used to mark sections of documentation which need to be reviewed.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.XmlCommentHelper.IsConsideredEmpty(Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax)">
            <summary>
            This helper is used by documentation diagnostics to check if a XML comment should be considered empty.
            A comment is empty if
            - it is null
            - it does not have any text in any XML element and it does not have an empty XML element in it.
            </summary>
            <param name="xmlComment">The xmlComment that should be checked</param>
            <returns>true, if the comment should be considered empty, false otherwise.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.XmlCommentHelper.IsConsideredEmpty(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax)">
            <summary>
            This helper is used by documentation diagnostics to check if a XML comment should be considered empty.
            A comment is empty if it does not have any text in any XML element and it does not have an empty XML element in it.
            </summary>
            <param name="xmlSyntax">The xmlSyntax that should be checked</param>
            <returns>true, if the comment should be considered empty, false otherwise.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.XmlCommentHelper.IsConsideredEmpty(System.Xml.Linq.XNode)">
            <summary>
            This helper is used by documentation diagnostics to check if an XML comment should be considered empty.
            A comment is empty if it does not have any text in any XML element and it does not have an empty XML element in it.
            </summary>
            <param name="node">The XML node that should be checked</param>
            <returns>true, if the comment should be considered empty, false otherwise.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.XmlCommentHelper.IsMissingOrEmpty(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Checks if a SyntaxTrivia contains a DocumentationCommentTriviaSyntax and returns true if it is considered empty
            </summary>
            <param name="commentTrivia">A SyntaxTrivia containing possible documentation</param>
            <returns>true if commentTrivia does not have documentation in it or the documentation in SyntaxTriviais considered empty. False otherwise.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.XmlCommentHelper.HasDocumentation(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Checks if a specific SyntaxNode has documentation in it's leading trivia.
            </summary>
            <param name="node">The syntax node that should be checked.</param>
            <returns>true if the node has documentation, false otherwise.</returns>
        </member>
        <member name="T:StyleCop.Analyzers.Helpers.XmlFileHeader">
            <summary>
            Class containing the parsed file header information.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.XmlFileHeader.#ctor(System.Xml.Linq.XElement,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.Helpers.XmlFileHeader"/> class.
            </summary>
            <param name="headerXml">The parsed XML tree from the header.</param>
            <param name="fileHeaderStart">The offset within the file at which the header started.</param>
            <param name="fileHeaderEnd">The offset within the file at which the header ended.</param>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.XmlFileHeader.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:StyleCop.Analyzers.Helpers.XmlFileHeader"/> class from being created.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.XmlFileHeader.MissingFileHeader">
            <summary>
            Gets a <see cref="T:StyleCop.Analyzers.Helpers.XmlFileHeader"/> instance representing a missing file header.
            </summary>
            <value>
            A <see cref="T:StyleCop.Analyzers.Helpers.XmlFileHeader"/> instance representing a missing file header.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.XmlFileHeader.MalformedFileHeader">
            <summary>
            Gets a <see cref="T:StyleCop.Analyzers.Helpers.XmlFileHeader"/> instance representing a missing file header.
            </summary>
            <value>
            A <see cref="T:StyleCop.Analyzers.Helpers.XmlFileHeader"/> instance representing a missing file header.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.XmlFileHeader.IsMissing">
            <summary>
            Gets a value indicating whether the file header is missing.
            </summary>
            <value>
            True if the file header is missing.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.Helpers.XmlFileHeader.IsMalformed">
            <summary>
            Gets a value indicating whether the file header contains a properly formatted XML structure.
            </summary>
            <value>
            True if the file header is not properly formatted XML.
            </value>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.XmlFileHeader.GetElement(System.String)">
            <summary>
            Gets a XML element from the file header with the given tag name.
            </summary>
            <param name="tagName">The tag name for the node.</param>
            <returns>The requested node, or null if the node could not be found.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.XmlFileHeader.GetLocation(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets the location representing the start of the file header.
            </summary>
            <param name="syntaxTree">The syntax tree to use for generating the location.</param>
            <returns>The location representing the start of the file header.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.Helpers.XmlFileHeader.GetElementLocation(Microsoft.CodeAnalysis.SyntaxTree,System.Xml.Linq.XElement)">
            <summary>
            Gets the location representing the position of the given element in the source file.
            </summary>
            <param name="syntaxTree">The syntax tree to use for generating the location.</param>
            <param name="element">The XML element to get the location of.</param>
            <returns>The location representing the position of the given element in the source file.</returns>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.ModifierOrderHelper.ModifierType">
            <summary>
            Represents modifier type for implementing SA1206 rule
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.ModifierOrderHelper.ModifierType.None">
            <summary>
            Represents default value
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.ModifierOrderHelper.ModifierType.Access">
            <summary>
            Represents any of access modifiers i.e public, protected, internal, private
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.ModifierOrderHelper.ModifierType.Static">
            <summary>
            Represents static modifier
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.ModifierOrderHelper.ModifierType.Other">
            <summary>
            Represents other modifiers i.e partial, virtual, abstract, override, extern, unsafe, new, async, const, sealed, readonly, volatile, fixed
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.OrderingResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.ElementOrderCodeFix">
            <summary>
              Looks up a localized string similar to Fix element order.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.ModifierOrderCodeFix">
            <summary>
              Looks up a localized string similar to Fix modifier order.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1201Description">
            <summary>
              Looks up a localized string similar to An element within a C# code file is out of order in relation to the other elements in the code..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1201MessageFormat">
            <summary>
              Looks up a localized string similar to A {0} should not follow a {1}.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1201Title">
            <summary>
              Looks up a localized string similar to Elements must appear in the correct order.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1202Description">
            <summary>
              Looks up a localized string similar to An element within a C# code file is out of order in relation to other elements in the code..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1202MessageFormat">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; members must come before &apos;{1}&apos; members.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1202Title">
            <summary>
              Looks up a localized string similar to Elements must be ordered by access.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1203Description">
            <summary>
              Looks up a localized string similar to A constant field is placed beneath a non-constant field..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1203MessageFormat">
            <summary>
              Looks up a localized string similar to Constant fields must appear before non-constant fields.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1203Title">
            <summary>
              Looks up a localized string similar to Constants must appear before fields.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1204Description">
            <summary>
              Looks up a localized string similar to A static element is positioned beneath an instance element..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1204MessageFormat">
            <summary>
              Looks up a localized string similar to Static members must appear before non-static members.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1204Title">
            <summary>
              Looks up a localized string similar to Static elements must appear before instance elements.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1205CodeFix">
            <summary>
              Looks up a localized string similar to Add access modifier.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1207CodeFix">
            <summary>
              Looks up a localized string similar to Place keyword &apos;protected&apos; before keyword &apos;internal&apos;.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1213CodeFix">
            <summary>
              Looks up a localized string similar to Fix accessor order.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1214Description">
            <summary>
              Looks up a localized string similar to A readonly field is positioned beneath a non-readonly field..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1214MessageFormat">
            <summary>
              Looks up a localized string similar to Readonly fields must appear before non-readonly fields.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.SA1214Title">
            <summary>
              Looks up a localized string similar to Readonly fields must appear before non-readonly fields.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.OrderingResources.UsingCodeFix">
            <summary>
              Looks up a localized string similar to Reorder using statements.
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1200UsingDirectivesMustBePlacedCorrectly">
             <summary>
             A C# using directive is placed outside of a namespace element.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when a using directive or a using-alias directive is placed outside of a
             namespace element, unless the file does not contain any namespace elements.</para>
            
             <para>For example, the following code would result in two violations of this rule.</para>
            
             <code language="cs">
             using System;
             using Guid = System.Guid;
            
             namespace Microsoft.Sample
             {
               public class Program
               {
               }
             }
             </code>
            
             <para>The following code, however, would not result in any violations of this rule:</para>
            
             <code language="cs">
             namespace Microsoft.Sample
             {
               using System;
               using Guid = System.Guid;
            
               public class Program
               {
               }
             }
             </code>
            
             <para>There are subtle differences between placing using directives within a namespace element, rather than
             outside of the namespace, including:</para>
            
             <list type="number">
             <item>Placing using-alias directives within the namespace eliminates compiler confusion between conflicting
             types.</item>
             <item>When multiple namespaces are defined within a single file, placing using directives within the namespace
             elements scopes references and aliases.</item>
             </list>
            
             <h2>1. Eliminating Type Confusion</h2>
            
             <para>Consider the following code, which contains a using-alias directive defined outside of the namespace
             element. The code creates a new class called <c>Guid</c>, and also defines a using-alias directive to map the
             name <c>Guid</c> to the type <see cref="T:System.Guid"/>. Finally, the code creates an instance of the type
             <c>Guid</c>:</para>
            
             <code language="cs">
             using Guid = System.Guid;
            
             namespace Microsoft.Sample
             {
               public class Guid
               {
                 public Guid(string s)
                 {
                 }
               }
            
               public class Program
               {
                 public static void Main(string[] args)
                 {
                   Guid g = new Guid("hello");
                 }
               }
             }
             </code>
            
             <para>This code will compile cleanly, without any compiler errors. However, it is unclear which version of the
             <c>Guid</c> type is being allocated. If the using directive is moved inside of the namespace, as shown below, a
             compiler error will occur:</para>
            
             <code language="cs">
             namespace Microsoft.Sample
             {
               using Guid = System.Guid;
            
               public class Guid
               {
                 public Guid(string s)
                 {
                 }
               }
            
               public class Program
               {
                 public static void Main(string[] args)
                 {
                   Guid g = new Guid("hello");
                 }
               }
             }
             </code>
            
             <para>The code fails on the following compiler error, found on the line containing
             <c>Guid g = new Guid("hello");</c></para>
            
             <quote>CS0576: Namespace 'Microsoft.Sample' contains a definition conflicting with alias 'Guid'</quote>
            
             <para>The code creates an alias to the <see cref="T:System.Guid"/> type called <c>Guid</c>, and also creates its own type
             called <c>Guid</c> with a matching constructor interface. Later, the code creates an instance of the type
             <c>Guid</c>. To create this instance, the compiler must choose between the two different definitions of
             <c>Guid</c>. When the using-alias directive is placed outside of the namespace element, the compiler will choose
             the local definition of <c>Guid</c> defined within the local namespace, and completely ignore the using-alias
             directive defined outside of the namespace. This, unfortunately, is not obvious when reading the code.</para>
            
             <para>When the using-alias directive is positioned within the namespace, however, the compiler has to choose
             between two different, conflicting <c>Guid</c> types both defined within the same namespace. Both of these types
             provide a matching constructor. The compiler is unable to make a decision, so it flags the compiler
             error.</para>
            
             <para>Placing the using-alias directive outside of the namespace is a bad practice because it can lead to
             confusion in situations such as this, where it is not obvious which version of the type is actually being used.
             This can potentially lead to a bug which might be difficult to diagnose.</para>
            
             <para>Placing using-alias directives within the namespace element eliminates this as a source of bugs.</para>
            
             <h2>2. Multiple Namespaces</h2>
            
             <para>Placing multiple namespace elements within a single file is generally a bad idea, but if and when this is
             done, it is a good idea to place all using directives within each of the namespace elements, rather than
             globally at the top of the file.This will scope the namespaces tightly, and will also help to avoid the kind of
             behavior described above.</para>
            
             <para>It is important to note that when code has been written with using directives placed outside of the
             namespace, care should be taken when moving these directives within the namespace, to ensure that this is not
             changing the semantics of the code.As explained above, placing using-alias directives within the namespace
             element allows the compiler to choose between conflicting types in ways that will not happen when the directives
             are placed outside of the namespace.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1200UsingDirectivesMustBePlacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.OrderingRules.SA1200UsingDirectivesMustBePlacedCorrectly"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1200UsingDirectivesMustBePlacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1200UsingDirectivesMustBePlacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1200UsingDirectivesMustBePlacedCorrectly.HandleCompilationUnit(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings)">
            <summary>
            This method reports a diagnostic for any using directive placed outside a namespace declaration. No
            diagnostics are reported unless <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.OrderingSettings.UsingDirectivesPlacement"/> is
            <see cref="F:StyleCop.Analyzers.Settings.ObjectModel.UsingDirectivesPlacement.InsideNamespace"/>.
            </summary>
            <param name="context">The analysis context.</param>
            <param name="settings">The effective StyleCop analysis settings.</param>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1200UsingDirectivesMustBePlacedCorrectly.HandleNamespaceDeclaration(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings)">
            <summary>
            This method reports a diagnostic for any using directive placed within a namespace declaration. No
            diagnostics are reported unless <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.OrderingSettings.UsingDirectivesPlacement"/> is
            <see cref="F:StyleCop.Analyzers.Settings.ObjectModel.UsingDirectivesPlacement.OutsideNamespace"/>.
            </summary>
            <param name="context">The analysis context.</param>
            <param name="settings">The effective StyleCop analysis settings.</param>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1201ElementsMustAppearInTheCorrectOrder">
             <summary>
             An element within a C# code file is out of order in relation to the other elements in the code.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the code elements within a file do not follow a standard ordering
             scheme.</para>
            
             <para>To comply with this rule, elements at the file root level or within a namespace must be positioned in the
             following order:</para>
            
             <list type="bullet">
             <item>Extern alias directives</item>
             <item>Using directives</item>
             <item>Namespaces</item>
             <item>Delegates</item>
             <item>Enums</item>
             <item>Interfaces</item>
             <item>Structs</item>
             <item>Classes</item>
             </list>
            
             <para>Within a class, struct, or interface, elements must be positioned in the following order:</para>
            
             <list type="bullet">
             <item>Fields</item>
             <item>Constructors</item>
             <item>Finalizers</item>
             <item>Delegates</item>
             <item>Events</item>
             <item>Enums</item>
             <item>Interfaces</item>
             <item>Properties</item>
             <item>Indexers</item>
             <item>Methods</item>
             <item>Structs</item>
             <item>Classes</item>
             </list>
            
             <para>Complying with a standard ordering scheme based on element type can increase the readability and
             maintainability of the file and encourage code reuse.</para>
            
             <para>When implementing an interface, it is sometimes desirable to group all members of the interface next to
             one another. This will sometimes require violating this rule, if the interface contains elements of different
             types. This problem can be solved through the use of partial classes.</para>
            
             <list type="number">
             <item>Add the partial attribute to the class, if the class is not already partial.</item>
             <item>Add a second partial class with the same name. It is possible to place this in the same file, just below
             the original class, or within a second file.</item>
             <item>Move the interface inheritance and all members of the interface implementation to the second part of the
             class.</item>
             </list>
            
             <para>For example:</para>
            
             <code language="csharp">
             /// &lt;summary&gt;
             /// Represents a customer of the system.
             /// &lt;/summary&gt;
             public partial class Customer
             {
                 // Contains the main functionality of the class.
             }
            
             /// &lt;content&gt;
             /// Implements the ICollection class.
             /// &lt;/content&gt;
             public partial class Customer : ICollection
             {
                 public int Count
                 {
                     get { return this.count; }
                 }
            
                 public bool IsSynchronized
                 {
                     get { return false; }
                 }
            
                 public object SyncRoot
                 {
                     get { return null; }
                 }
            
                 public void CopyTo(Array array, int index)
                 {
                     throw new NotImplementedException();
                 }
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1201ElementsMustAppearInTheCorrectOrder.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.OrderingRules.SA1201ElementsMustAppearInTheCorrectOrder"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1201ElementsMustAppearInTheCorrectOrder.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1201ElementsMustAppearInTheCorrectOrder.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1202ElementsMustBeOrderedByAccess">
             <summary>
             An element within a C# code file is out of order within regard to access level, in relation to other elements in
             the code.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the code elements within a file do not follow a standard ordering
             scheme based on access level.</para>
            
             <para>To comply with this rule, adjacent elements of the same type must be positioned in the following order by
             access level:</para>
            
             <list type="bullet">
             <item>public</item>
             <item>internal</item>
             <item>protected internal</item>
             <item>protected</item>
             <item>private</item>
             </list>
            
             <para>Complying with a standard ordering scheme based on access level can increase the readability and
             maintainability of the file and make it easier to identify the public interface that is being exposed from a
             class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1202ElementsMustBeOrderedByAccess.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.OrderingRules.SA1202ElementsMustBeOrderedByAccess"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1202ElementsMustBeOrderedByAccess.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1202ElementsMustBeOrderedByAccess.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1203ConstantsMustAppearBeforeFields">
            <summary>
            A constant field is placed beneath a non-constant field.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when a constant field is placed beneath a non-constant field. Constants
            must be placed above fields to indicate that the two are fundamentally different types of elements with
            different considerations for the compiler, different naming requirements, etc.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1203ConstantsMustAppearBeforeFields.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.OrderingRules.SA1203ConstantsMustAppearBeforeFields"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1203ConstantsMustAppearBeforeFields.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1203ConstantsMustAppearBeforeFields.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1204StaticElementsMustAppearBeforeInstanceElements">
            <summary>
            A static element is positioned beneath an instance element of the same type.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when a static element is positioned beneath an instance element of the
            same type. All static elements must be placed above all instance elements of the same type to make it easier to
            see the interface exposed from the instance and static version of the class.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1204StaticElementsMustAppearBeforeInstanceElements.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.OrderingRules.SA1204StaticElementsMustAppearBeforeInstanceElements"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1204StaticElementsMustAppearBeforeInstanceElements.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1204StaticElementsMustAppearBeforeInstanceElements.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1205PartialElementsMustDeclareAccess">
            <summary>
            The partial element does not have an access modifier defined.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when the partial elements does not have an access modifier defined.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1205PartialElementsMustDeclareAccess.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.OrderingRules.SA1205PartialElementsMustDeclareAccess"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1205PartialElementsMustDeclareAccess.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1205PartialElementsMustDeclareAccess.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1206DeclarationKeywordsMustFollowOrder">
             <summary>
             The keywords within the declaration of an element do not follow a standard ordering scheme.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the keywords within an element’s declaration do not follow a standard
             ordering scheme.</para>
            
             <para>Within an element declaration, keywords must appear in the following order:</para>
            
             <list type="bullet">
             <item>Access modifiers</item>
             <item><see langword="static"/></item>
             <item>All other keywords</item>
             </list>
            
             <para>Using a standard ordering scheme for element declaration keywords can make the code more readable by
             highlighting the access level of each element. This can help prevent elements from being given a higher access
             level than needed.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1206DeclarationKeywordsMustFollowOrder.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.OrderingRules.SA1206DeclarationKeywordsMustFollowOrder"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1206DeclarationKeywordsMustFollowOrder.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1206DeclarationKeywordsMustFollowOrder.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1207ProtectedMustComeBeforeInternal">
            <summary>
            The keyword <c>protected</c> is positioned after the keyword <c>internal</c> within the declaration of a
            protected internal C# element.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when a protected internal element's access modifiers are written as
            <c>internal protected</c>. In reality, an element with the keywords <c>protected internal</c> will have the same
            access level as an element with the keywords <c>internal protected</c>. To make the code easier to read and more
            consistent, StyleCop standardizes the ordering of these keywords, so that a protected internal element will
            always be described as such, and never as internal protected. This can help to reduce confusion about whether
            these access levels are indeed the same.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1207ProtectedMustComeBeforeInternal.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.OrderingRules.SA1207ProtectedMustComeBeforeInternal"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1207ProtectedMustComeBeforeInternal.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1207ProtectedMustComeBeforeInternal.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1208SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives">
            <summary>
            A using directive which declares a member of the <see cref="N:System"/> namespace appears after a using directive
            which declares a member of a different namespace, within a C# code file.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when a using directive for the <see cref="N:System"/> namespace is placed
            after a non-<see cref="N:System"/> using directive. Placing all <see cref="N:System"/> using directives at the top
            of the using directives can make the code cleaner and easier to read, and can help make it easier to identify
            the namespaces that are being used by the code.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1208SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.OrderingRules.SA1208SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1208SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1208SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1209UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives">
            <summary>
            A using-alias directive is positioned before a regular using directive.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when a using-alias directive is placed before a normal using directive.
            Using-alias directives have special behavior which can alter the meaning of the rest of the code within the file
            or namespace. Placing the using-alias directives together below all other using-directives can make the code
            cleaner and easier to read, and can help make it easier to identify the types used throughout the code.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1209UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.OrderingRules.SA1209UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1209UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1209UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1210UsingDirectivesMustBeOrderedAlphabeticallyByNamespace">
            <summary>
            The using directives within a C# code file are not sorted alphabetically by namespace.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when the using directives are not sorted alphabetically by namespace.
            Sorting the using directives alphabetically makes the code cleaner and easier to read, and can help make it
            easier to identify the namespaces that are being used by the code. The <see cref="N:System"/> namespaces are an
            exception to this rule and will always precede all other namespaces. See
            <see cref="T:StyleCop.Analyzers.OrderingRules.SA1208SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives"/> for more details.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1210UsingDirectivesMustBeOrderedAlphabeticallyByNamespace.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.OrderingRules.SA1210UsingDirectivesMustBeOrderedAlphabeticallyByNamespace"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1210UsingDirectivesMustBeOrderedAlphabeticallyByNamespace.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1210UsingDirectivesMustBeOrderedAlphabeticallyByNamespace.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1211UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName">
            <summary>
            The using-alias directives within a C# code file are not sorted alphabetically by alias name.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when the using-alias directives are not sorted alphabetically by alias
            name. Sorting the using-alias directives alphabetically can make the code cleaner and easier to read, and can
            help make it easier to identify the namespaces that are being used by the code.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1211UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.OrderingRules.SA1211UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1211UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1211UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1212PropertyAccessorsMustFollowOrder">
             <summary>
             A get accessor appears after a set accessor within a property or indexer.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when a get accessor is placed after a set accessor within a property or
             indexer. To comply with this rule, the get accessor should appear before the set accessor.</para>
            
             <para>For example, the following code would raise an instance of this violation:</para>
            
             <code language="csharp">
             public string Name
             {
                 set { this.name = value; }
                 get { return this.name; }
             }
             </code>
            
             <para>The code below would not raise this violation:</para>
            
             <code language="csharp">
             public string Name
             {
                 get { return this.name; }
                 set { this.name = value; }
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1212PropertyAccessorsMustFollowOrder.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.OrderingRules.SA1212PropertyAccessorsMustFollowOrder"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1212PropertyAccessorsMustFollowOrder.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1212PropertyAccessorsMustFollowOrder.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1213EventAccessorsMustFollowOrder">
             <summary>
             An add accessor appears after a remove accessor within an event.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when an add accessor is placed after a remove accessor within an event. To
             comply with this rule, the add accessor should appear before the remove accessor.</para>
            
             <para>For example, the following code would raise an instance of this violation:</para>
            
             <code language="csharp">
             public event EventHandler NameChanged
             {
                 remove { this.nameChanged -= value; }
                 add { this.nameChanged += value; }
             }
             </code>
            
             <para>The code below would not raise this violation:</para>
            
             <code language="csharp">
             public event EventHandler NameChanged
             {
                 add { this.nameChanged += value; }
                 remove { this.nameChanged -= value; }
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1213EventAccessorsMustFollowOrder.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.OrderingRules.SA1213EventAccessorsMustFollowOrder"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1213EventAccessorsMustFollowOrder.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1213EventAccessorsMustFollowOrder.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1214ReadonlyElementsMustAppearBeforeNonReadonlyElements">
            <summary>
            An readonly element is positioned beneath a non-readonly element.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1214ReadonlyElementsMustAppearBeforeNonReadonlyElements.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.OrderingRules.SA1214ReadonlyElementsMustAppearBeforeNonReadonlyElements"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1214ReadonlyElementsMustAppearBeforeNonReadonlyElements.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1214ReadonlyElementsMustAppearBeforeNonReadonlyElements.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1216UsingStaticDirectivesMustBePlacedAtTheCorrectLocation">
            <summary>
            A static using directive is positioned at the wrong location.
            </summary>
            <remarks>
            <para>
            A violation of this rule occurs when a using static directive is placed before a normal or after an alias using directive.
            Placing the using static directives together below normal and before alias using-directives can make the code cleaner and easier to read,
            and can help make it easier to identify the static members used throughout the code.
            </para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1216UsingStaticDirectivesMustBePlacedAtTheCorrectLocation.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.OrderingRules.SA1216UsingStaticDirectivesMustBePlacedAtTheCorrectLocation"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1216UsingStaticDirectivesMustBePlacedAtTheCorrectLocation.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1216UsingStaticDirectivesMustBePlacedAtTheCorrectLocation.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.OrderingRules.SA1217UsingStaticDirectivesMustBeOrderedAlphabetically">
            <summary>
            A static using directive is positioned at the wrong location.
            </summary>
            <remarks>
            <para>
            A violation of this rule occurs when a using static directive is placed before a normal or an alias using directive.
            Placing the using static directives together below normal and alias using-directives can make the code cleaner and easier to read,
            and can help make it easier to identify the static members used throughout the code.
            </para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.OrderingRules.SA1217UsingStaticDirectivesMustBeOrderedAlphabetically.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.OrderingRules.SA1217UsingStaticDirectivesMustBeOrderedAlphabetically"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.OrderingRules.SA1217UsingStaticDirectivesMustBeOrderedAlphabetically.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.OrderingRules.SA1217UsingStaticDirectivesMustBeOrderedAlphabetically.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.LayoutResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1500CodeFix">
            <summary>
              Looks up a localized string similar to Align braces.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1501CodeFix">
            <summary>
              Looks up a localized string similar to Expand single line block.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1502CodeFix">
            <summary>
              Looks up a localized string similar to Expand element.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1502Description">
            <summary>
              Looks up a localized string similar to A C# element containing opening and closing braces is written completely on a single line..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1502MessageFormat">
            <summary>
              Looks up a localized string similar to Element must not be on a single line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1502Title">
            <summary>
              Looks up a localized string similar to Element must not be on a single line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1503CodeFix">
            <summary>
              Looks up a localized string similar to Wrap with braces.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1504CodeFixMultipleLines">
            <summary>
              Looks up a localized string similar to Reformat accessors to multiple lines style.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1504CodeFixSingleLine">
            <summary>
              Looks up a localized string similar to Reformat accessors to single line style.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1505CodeFix">
            <summary>
              Looks up a localized string similar to Remove blank lines following this brace.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1506CodeFix">
            <summary>
              Looks up a localized string similar to Remove blank line(s) after documentation header.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1507CodeFix">
            <summary>
              Looks up a localized string similar to Remove multiple blank lines.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1508CodeFix">
            <summary>
              Looks up a localized string similar to Remove blank lines preceding this brace.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1509CodeFix">
            <summary>
              Looks up a localized string similar to Remove blank lines preceding this brace.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1510CodeFix">
            <summary>
              Looks up a localized string similar to Remove blank line before chained statement.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1511CodeFix">
            <summary>
              Looks up a localized string similar to Remove blank line before while.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1512CodeFix">
            <summary>
              Looks up a localized string similar to Remove blank line after comment.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1513CodeFix">
            <summary>
              Looks up a localized string similar to Insert blank line after brace.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1514CodeFix">
            <summary>
              Looks up a localized string similar to Insert blank line before documentation header.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1515CodeFix">
            <summary>
              Looks up a localized string similar to Insert blank line before comment.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1516CodeFix">
            <summary>
              Looks up a localized string similar to Insert new line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1517CodeFix">
            <summary>
              Looks up a localized string similar to Remove blank lines at the start of the file.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1518CodeFix">
            <summary>
              Looks up a localized string similar to Fix whitespace at the end of the file.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1518DescriptionAllow">
            <summary>
              Looks up a localized string similar to Code must not contain blank lines at the end of the file.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1518DescriptionOmit">
            <summary>
              Looks up a localized string similar to File may not end with a newline character.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1518DescriptionRequire">
            <summary>
              Looks up a localized string similar to File is required to end with a single newline character.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1518MessageFormatAllow">
            <summary>
              Looks up a localized string similar to Code must not contain blank lines at the end of the file.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1518MessageFormatOmit">
            <summary>
              Looks up a localized string similar to File may not end with a newline character.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1518MessageFormatRequire">
            <summary>
              Looks up a localized string similar to File is required to end with a single newline character.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.LayoutResources.SA1518Title">
            <summary>
              Looks up a localized string similar to Use line endings correctly at end of file.
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1500BracesForMultiLineStatementsMustNotShareLine">
             <summary>
             The opening or closing brace within a C# statement, element, or expression is not placed on its own line.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the opening or closing brace within a statement, element, or
             expression is not placed on its own line. For example:</para>
            
             <code language="cs">
             public object Method()
             {
               lock (this) {
                 return this.value;
               }
             }
             </code>
            
             <para>When StyleCop checks this code, a violation of this rule will occur because the opening brace of the lock
             statement is placed on the same line as the lock keyword, rather than being placed on its own line, as
             follows:</para>
            
             <code language="cs">
             public object Method()
             {
               lock (this)
               {
                 return this.value;
               }
             }
             </code>
            
             <para>A violation will also occur if the closing brace shares a line with other code. For example:</para>
            
             <code language="cs">
             public object Method()
             {
               lock (this)
               {
                 return this.value; }
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1500BracesForMultiLineStatementsMustNotShareLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.LayoutRules.SA1500BracesForMultiLineStatementsMustNotShareLine"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1500BracesForMultiLineStatementsMustNotShareLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1500BracesForMultiLineStatementsMustNotShareLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1501StatementMustNotBeOnASingleLine">
             <summary>
             A C# statement containing opening and closing braces is written completely on a single line.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when a statement that is wrapped in opening and closing braces is written
             on a single line. For example:</para>
            
             <code language="csharp">
             public object Method()
             {
                 lock (this) { return this.value; }
             }
             </code>
            
             <para>When StyleCop checks this code, a violation of this rule will occur because the entire lock statement is
             written on one line. The statement should be written across multiple lines, with the opening and closing braces
             each on their own line, as follows:</para>
            
             <code language="csharp">
             public object Method()
             {
                 lock (this)
                 {
                     return this.value;
                 }
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1501StatementMustNotBeOnASingleLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1501StatementMustNotBeOnASingleLine"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1501StatementMustNotBeOnASingleLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1501StatementMustNotBeOnASingleLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1502ElementMustNotBeOnASingleLine">
             <summary>
             A C# element containing opening and closing braces is written completely on a single line.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when an element that is wrapped in opening and closing braces is written
             on a single line. For example:</para>
             <code language="csharp">
             public object Method() { return null; }
             </code>
            
             <para>When StyleCop checks this code, a violation of this rule will occur because the entire method is written
             on one line. The method should be written across multiple lines, with the opening and closing braces each on
             their own line, as follows:</para>
            
             <code language="csharp">
             public object Method()
             {
                 return null;
             }
             </code>
            
             <para>As an exception to this rule, accessors within properties, events, or indexers are allowed to be written
             all on a single line, as long as the accessor is short.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1502ElementMustNotBeOnASingleLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1502ElementMustNotBeOnASingleLine"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1502ElementMustNotBeOnASingleLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1502ElementMustNotBeOnASingleLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1503BracesMustNotBeOmitted">
             <summary>
             The opening and closing braces for a C# statement have been omitted.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the opening and closing braces for a statement have been omitted. In
             C#, some types of statements may optionally include braces. Examples include <c>if</c>, <c>while</c>, and
             <c>for</c> statements. For example, an if-statement may be written without braces:</para>
            
             <code language="csharp">
             if (true)
                 return this.value;
             </code>
            
             <para>Although this is legal in C#, StyleCop always requires the braces to be present, to increase the
             readability and maintainability of the code.</para>
            
             <para>When the braces are omitted, it is possible to introduce an error in the code by inserting an additional
             statement beneath the if-statement. For example:</para>
            
             <code language="csharp">
             if (true)
                 this.value = 2;
                 return this.value;
             </code>
            
             <para>Glancing at this code, it appears as if both the assignment statement and the return statement are
             children of the if-statement. In fact, this is not true. Only the assignment statement is a child of the
             if-statement, and the return statement will always execute regardless of the outcome of the if-statement.</para>
            
             <para>StyleCop always requires the opening and closing braces to be present, to prevent these kinds of
             errors:</para>
            
             <code language="csharp">
             if (true)
             {
                 this.value = 2;
                 return this.value;
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1503BracesMustNotBeOmitted.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1503BracesMustNotBeOmitted"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1503BracesMustNotBeOmitted.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1503BracesMustNotBeOmitted.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1504AllAccessorsMustBeSingleLineOrMultiLine">
             <summary>
             Within a C# property, indexer or event, at least one of the child accessors is written on a single line, and at
             least one of the child accessors is written across multiple lines.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the accessors within a property, indexer or event are not
             consistently written on a single line or on multiple lines. This rule is intended to increase the readability of
             the code by requiring all of the accessors within an element to be formatted in the same way.</para>
            
             <para>For example, the following property would generate a violation of this rule, because one accessor is
             written on a single line while the other accessor snaps multiple lines.</para>
            
             <code language="csharp">
             public bool Enabled
             {
                 get { return this.enabled; }
            
                 set
                 {
                     this.enabled = value;
                 }
             }
             </code>
            
             <para>The violation can be avoided by placing both accessors on a single line, or expanding both accessors
             across multiple lines:</para>
            
             <code language="csharp">
             public bool Enabled
             {
                 get { return this.enabled; }
                 set { this.enabled = value; }
             }
            
             public bool Enabled
             {
                 get
                 {
                     return this.enabled;
                 }
            
                 set
                 {
                     this.enabled = value;
                 }
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1504AllAccessorsMustBeSingleLineOrMultiLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1504AllAccessorsMustBeSingleLineOrMultiLine"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1504AllAccessorsMustBeSingleLineOrMultiLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1504AllAccessorsMustBeSingleLineOrMultiLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1505OpeningBracesMustNotBeFollowedByBlankLine">
             <summary>
             An opening brace within a C# element, statement, or expression is followed by a blank line.
             </summary>
             <remarks>
             <para>To improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits
             blank lines in other situations. This results in a consistent visual pattern across the code, which can improve
             recognition and readability of unfamiliar code.</para>
            
             <para>A violation of this rule occurs when an opening brace is followed by a blank line. For example:</para>
            
             <code>
             public bool Enabled
             {
            
                 get
                 {
            
                     return this.enabled;
                 }
             }
             </code>
            
             <para>The code above would generate two instances of this violation, since there are two places where opening
             braces are followed by blank lines.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1505OpeningBracesMustNotBeFollowedByBlankLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1505OpeningBracesMustNotBeFollowedByBlankLine"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1505OpeningBracesMustNotBeFollowedByBlankLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1505OpeningBracesMustNotBeFollowedByBlankLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1506ElementDocumentationHeadersMustNotBeFollowedByBlankLine">
             <summary>
             An element documentation header above a C# element is followed by a blank line.
             </summary>
             <remarks>
             <para>To improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits
             blank lines in other situations. This results in a consistent visual pattern across the code, which can improve
             recognition and readability of unfamiliar code.</para>
            
             <para>A violation of this rule occurs when the element documentation header above an element is followed by a
             blank line. For example:</para>
            
             <code language="csharp">
             /// <summary>
             /// Gets a value indicating whether the control is enabled.
             /// </summary>
            
             public bool Enabled
             {
                 get { return this.enabled; }
             }
             </code>
            
             <para>The code above would generate an instance of this violation, since the documentation header is followed by
             a blank line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1506ElementDocumentationHeadersMustNotBeFollowedByBlankLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.LayoutRules.SA1506ElementDocumentationHeadersMustNotBeFollowedByBlankLine"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1506ElementDocumentationHeadersMustNotBeFollowedByBlankLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1506ElementDocumentationHeadersMustNotBeFollowedByBlankLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1507CodeMustNotContainMultipleBlankLinesInARow">
             <summary>
             The C# code contains multiple blank lines in a row.
             </summary>
             <remarks>
             <para>To improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits
             blank lines in other situations. This results in a consistent visual pattern across the code, which can improve
             recognition and readability of unfamiliar code.</para>
            
             <para>A violation of this rule occurs when the code contains more than one blank line in a row. For
             example:</para>
            
             <code language="csharp">
             public bool Enabled
             {
                 get
                 {
                     Console.WriteLine("Getting the enabled flag.");
            
            
                     return this.enabled;
                 }
             }
             </code>
            
             <para>The code above would generate an instance of this violation, since it contains blank multiple lines in a
             row.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1507CodeMustNotContainMultipleBlankLinesInARow.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1507CodeMustNotContainMultipleBlankLinesInARow"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1507CodeMustNotContainMultipleBlankLinesInARow.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1507CodeMustNotContainMultipleBlankLinesInARow.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1508ClosingBracesMustNotBePrecededByBlankLine">
             <summary>
             A closing brace within a C# element, statement, or expression is preceded by a blank line.
             </summary>
             <remarks>
             <para>To improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits
             blank lines in other situations. This results in a consistent visual pattern across the code, which can improve
             recognition and readability of unfamiliar code.</para>
            
             <para>A violation of this rule occurs when a closing brace is preceded by a blank line. For example:</para>
            
             <code language="csharp">
             public bool Enabled
             {
                 get
                 {
                     return this.enabled;
            
                 }
            
             }
             </code>
            
             <para>The code above would generate two instances of this violation, since there are two places where closing
             braces are preceded by blank lines.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1508ClosingBracesMustNotBePrecededByBlankLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1508ClosingBracesMustNotBePrecededByBlankLine"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1508ClosingBracesMustNotBePrecededByBlankLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1508ClosingBracesMustNotBePrecededByBlankLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1509OpeningBracesMustNotBePrecededByBlankLine">
             <summary>
             An opening brace within a C# element, statement, or expression is preceded by a blank line.
             </summary>
             <remarks>
             <para>To improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits
             blank lines in other situations. This results in a consistent visual pattern across the code, which can improve
             recognition and readability of unfamiliar code.</para>
            
             <para>A violation of this rule occurs when an opening brace is preceded by a blank line. For example:</para>
            
             <code language="csharp">
             public bool Enabled
            
             {
                 get
            
                 {
                     return this.enabled;
                 }
             }
             </code>
            
             <para>The code above would generate two instances of this violation, since there are two places where opening
             braces are preceded by blank lines.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1509OpeningBracesMustNotBePrecededByBlankLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1509OpeningBracesMustNotBePrecededByBlankLine"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1509OpeningBracesMustNotBePrecededByBlankLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1509OpeningBracesMustNotBePrecededByBlankLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1510ChainedStatementBlocksMustNotBePrecededByBlankLine">
             <summary>
             Chained C# statements are separated by a blank line.
             </summary>
             <remarks>
             <para>To improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits
             blank lines in other situations. This results in a consistent visual pattern across the code, which can improve
             recognition and readability of unfamiliar code.</para>
            
             <para>Some types of C# statements can only be used when chained to the bottom of another statement. Examples
             include catch and finally statements, which must always be chained to the bottom of a try-statement. Another
             example is an else-statement, which must always be chained to the bottom of an if-statement, or to another
             else-statement. These types of chained statements must not be separated by a blank line. For example:</para>
            
             <code language="csharp">
             try
             {
                 this.SomeMethod();
             }
            
             catch (Exception ex)
             {
                 Console.WriteLine(ex.ToString());
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1510ChainedStatementBlocksMustNotBePrecededByBlankLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.LayoutRules.SA1510ChainedStatementBlocksMustNotBePrecededByBlankLine"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1510ChainedStatementBlocksMustNotBePrecededByBlankLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1510ChainedStatementBlocksMustNotBePrecededByBlankLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1511WhileDoFooterMustNotBePrecededByBlankLine">
             <summary>
             The while footer at the bottom of a do-while statement is separated from the statement by a blank line.
             </summary>
             <remarks>
             <para>To improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits
             blank lines in other situations. This results in a consistent visual pattern across the code, which can improve
             recognition and readability of unfamiliar code.</para>
            
             <para>A violation of this rule occurs when the while keyword at the bottom of a do-while statement is separated
             from the main part of the statement by one or more blank lines. For example:</para>
            
             <code language="csharp">
             do
             {
                 Console.WriteLine("Loop forever");
             }
            
             while (true);
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1511WhileDoFooterMustNotBePrecededByBlankLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1511WhileDoFooterMustNotBePrecededByBlankLine"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1511WhileDoFooterMustNotBePrecededByBlankLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1511WhileDoFooterMustNotBePrecededByBlankLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1512SingleLineCommentsMustNotBeFollowedByBlankLine">
             <summary>
             A single-line comment within C# code is followed by a blank line.
             </summary>
             <remarks>
             <para>To improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits
             blank lines in other situations. This results in a consistent visual pattern across the code, which can improve
             recognition and readability of unfamiliar code.</para>
            
             <para>A violation of this rule occurs when a single-line comment is followed by a blank line. For
             example:</para>
            
             <code language="csharp">
             public bool Enabled
             {
                 get
                 {
                     // Return the value of the 'enabled' field.
            
                     return this.enabled;
                 }
             }
             </code>
            
             <para>The code above would generate an instance of this violation, since the single-line comment is followed by
             a blank line.</para>
            
             <para>It is allowed to place a blank line in between two blocks of single-line comments. For example:</para>
            
             <code language="csharp">
             public bool Enabled
             {
                 get
                 {
                     // This is a sample comment which doesn't really say anything.
                     // This is another part of the comment.
            
                     // There is a blank line above this comment but that is ok.
                     return this.enabled;
                 }
             }
             </code>
            
             <para>If the comment is being used to comment out a line of code, place four forward slashes at the beginning of
             the comment, rather than two. This will cause StyleCop to ignore this violation. For example:</para>
            
             <code language="csharp">
             public bool Enabled
             {
                 get
                 {
                     ////return false;
            
                     return this.enabled;
                 }
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1512SingleLineCommentsMustNotBeFollowedByBlankLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1512SingleLineCommentsMustNotBeFollowedByBlankLine"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1512SingleLineCommentsMustNotBeFollowedByBlankLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1512SingleLineCommentsMustNotBeFollowedByBlankLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1513ClosingBraceMustBeFollowedByBlankLine">
             <summary>
             A closing brace within a C# element, statement, or expression is not followed by a blank line.
             </summary>
             <remarks>
             <para>To improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits
             blank lines in other situations. This results in a consistent visual pattern across the code, which can improve
             recognition and readability of unfamiliar code.</para>
            
             <para>A violation of this rule occurs when a closing brace is not followed by a blank line. For example:</para>
            
             <code language="csharp">
             public bool Enabled
             {
                 get
                 {
                     return this.enabled;
                 }}
             </code>
            
             <para>The code above would generate one instance of this violation, since there is one place where a closing
             brace is not followed by a blank line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1513ClosingBraceMustBeFollowedByBlankLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1513ClosingBraceMustBeFollowedByBlankLine"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1513ClosingBraceMustBeFollowedByBlankLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1513ClosingBraceMustBeFollowedByBlankLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1514ElementDocumentationHeaderMustBePrecededByBlankLine">
             <summary>
             An element documentation header above a C# element is not preceded by a blank line.
             </summary>
             <remarks>
             <para>To improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits
             blank lines in other situations. This results in a consistent visual pattern across the code, which can improve
             recognition and readability of unfamiliar code.</para>
            
             <para>A violation of this rule occurs when the element documentation header above an element is not preceded by
             a blank line. For example:</para>
            
             <code language="csharp">
             public bool Visible
             {
                 get { return this.visible; }
             }
             /// &lt;summary&gt;
             /// Gets a value indicating whether the control is enabled.
             /// &lt;/summary&gt;
             public bool Enabled
             {
                 get { return this.enabled; }
             }
             </code>
            
             <para>The code above would generate an instance of this violation, since the documentation header is not
             preceded by a blank line.</para>
            
             <para>An exception to this rule occurs when the documentation header is the first item within its scope. In this
             case, the header should not be preceded by a blank line. For example:</para>
            
             <code language="csharp">
             public class Class1
             {
                 /// &lt;summary&gt;
                 /// Gets a value indicating whether the control is enabled.
                 /// &lt;/summary&gt;
                 public bool Enabled
                 {
                     get { return this.enabled; }
                 }
             }
             </code>
            
             <para>In the code above, the header is the first item within its scope, and thus it should not be preceded by a
             blank line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1514ElementDocumentationHeaderMustBePrecededByBlankLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.LayoutRules.SA1514ElementDocumentationHeaderMustBePrecededByBlankLine"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1514ElementDocumentationHeaderMustBePrecededByBlankLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1514ElementDocumentationHeaderMustBePrecededByBlankLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1515SingleLineCommentMustBePrecededByBlankLine">
             <summary>
             A single-line comment within C# code is not preceded by a blank line.
             </summary>
             <remarks>
             <para>To improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits
             blank lines in other situations. This results in a consistent visual pattern across the code, which can improve
             recognition and readability of unfamiliar code.</para>
            
             <para>A violation of this rule occurs when a single-line comment is not preceded by a blank line. For
             example:</para>
            
             <code language="csharp">
             public bool Enabled
             {
                 get
                 {
                     Console.WriteLine("Getting the enabled flag.");
                     // Return the value of the 'enabled' field.
                     return this.enabled;
                 }
             }
             </code>
            
             <para>The code above would generate an instance of this violation, since the single-line comment is not preceded
             by a blank line.</para>
            
             <para>An exception to this rule occurs when the single-line comment is the first item within its scope. In this
             case, the comment should not be preceded by a blank line. For example:</para>
            
             <code language="csharp">
             public bool Enabled
             {
                 get
                 {
                     // Return the value of the 'enabled' field.
                     return this.enabled;
                 }
             }
             </code>
            
             <para>In the code above, the comment is the first item within its scope, and thus it should not be preceded by a
             blank line.</para>
            
             <para>If the comment is being used to comment out a line of code, begin the comment with four forward slashes
             rather than two. This will cause StyleCop to ignore this violation. For example:</para>
            
             <code language="csharp">
             public bool Enabled
             {
                 get
                 {
                     Console.WriteLine("Getting the enabled flag.");
                     ////return false;
                     return this.enabled;
                 }
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1515SingleLineCommentMustBePrecededByBlankLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1515SingleLineCommentMustBePrecededByBlankLine"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1515SingleLineCommentMustBePrecededByBlankLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1515SingleLineCommentMustBePrecededByBlankLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1516ElementsMustBeSeparatedByBlankLine">
             <summary>
             Adjacent C# elements are not separated by a blank line.
             </summary>
             <remarks>
             <para>To improve the readability of the code, StyleCop requires blank lines in certain situations, and prohibits
             blank lines in other situations. This results in a consistent visual pattern across the code, which can improve
             recognition and readability of unfamiliar code.</para>
            
             <para>A violation of this rule occurs when two adjacent element are not separated by a blank line. For
             example:</para>
            
             <code language="csharp">
             public void Method1()
             {
             }
             public bool Property
             {
                 get { return true; }
             }
             </code>
            
             <para>In the example above, the method and property are not separated by a blank line, so a violation of this
             rule would occur.</para>
            
             <code language="csharp">
             public event EventHandler SomeEvent
             {
                 add
                 {
                     // add event subscriber here
                 }
                 remove
                 {
                     // remove event subscriber here
                 }
             }
             </code>
            
             <para>In the example above, the add and remove of the event need to be separated by a blank line because the add
             is multi-line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1516ElementsMustBeSeparatedByBlankLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1516ElementsMustBeSeparatedByBlankLine"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1516ElementsMustBeSeparatedByBlankLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1516ElementsMustBeSeparatedByBlankLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1517CodeMustNotContainBlankLinesAtStartOfFile">
             <summary>
             The code file has blank lines at the start.
             </summary>
             <remarks>
             <para>To improve the layout of the code, StyleCop requires no blank lines at the start of files.</para>
            
             <para>A violation of this rule occurs when one or more blank lines are at the start of the file.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1517CodeMustNotContainBlankLinesAtStartOfFile.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1517CodeMustNotContainBlankLinesAtStartOfFile"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1517CodeMustNotContainBlankLinesAtStartOfFile.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1517CodeMustNotContainBlankLinesAtStartOfFile.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1518UseLineEndingsCorrectlyAtEndOfFile">
             <summary>
             The code file has blank lines at the end.
             </summary>
             <remarks>
             <para>To improve the layout of the code, StyleCop requires no blank lines at the end of files.</para>
            
             <para>A violation of this rule occurs when one or more blank lines are at the end of the file.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1518UseLineEndingsCorrectlyAtEndOfFile.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1518UseLineEndingsCorrectlyAtEndOfFile"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1518UseLineEndingsCorrectlyAtEndOfFile.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1518UseLineEndingsCorrectlyAtEndOfFile.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1519BracesMustNotBeOmittedFromMultiLineChildStatement">
             <summary>
             The opening and closing braces for a multi-line C# statement have been omitted.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the opening and closing braces for a multi-line statement have been
             omitted. In C#, some types of statements may optionally include braces. Examples include <c>if</c>,
             <c>while</c>, and <c>for</c> statements. For example, an if-statement may be written without braces:</para>
            
             <code language="csharp">
             if (true)
                 return
                     this.value;
             </code>
            
             <para>Although this is legal in C#, StyleCop requires the braces to be present when the statement spans multiple
             lines, to increase the readability and maintainability of the code.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1519BracesMustNotBeOmittedFromMultiLineChildStatement.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1519BracesMustNotBeOmittedFromMultiLineChildStatement"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1519BracesMustNotBeOmittedFromMultiLineChildStatement.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1519BracesMustNotBeOmittedFromMultiLineChildStatement.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.LayoutRules.SA1520UseBracesConsistently">
             <summary>
             The opening and closing braces of a chained <c>if</c>/<c>else if</c>/<c>else</c> construct were included for
             some clauses, but omitted for others.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the opening and closing braces for a chained statement have been
             included for some clauses but omitted for others. In C#, some types of statements may optionally include
             braces. For example, an <c>if</c>-statement may be written with inconsistent braces:</para>
            
             <code language="csharp">
             if (true)
                 return this.value;
             else
             {
                 return that.value.
             }
             </code>
            
             <para>Although this is legal in C#, StyleCop requires the braces to be present for all clauses of a chained
             <c>if</c>/<c>else if</c>/<c>else</c> construct when braces are included for any clause, to increase the
             readability and maintainability of the code.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.LayoutRules.SA1520UseBracesConsistently.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.LayoutRules.SA1520UseBracesConsistently"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.LayoutRules.SA1520UseBracesConsistently.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.LayoutRules.SA1520UseBracesConsistently.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources.SA1119CodeFix">
            <summary>
              Looks up a localized string similar to Remove parentheses.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources.SA1400CodeFix">
            <summary>
              Looks up a localized string similar to Declare accessibility.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources.SA1402CodeFix">
            <summary>
              Looks up a localized string similar to Move type to new file.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources.SA1404CodeFix">
            <summary>
              Looks up a localized string similar to Fix justification.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources.SA1407SA1408CodeFix">
            <summary>
              Looks up a localized string similar to Add parentheses.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources.SA1410SA1411CodeFix">
            <summary>
              Looks up a localized string similar to Remove parentheses.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources.SA1412CodeFix">
            <summary>
              Looks up a localized string similar to Change encoding from &apos;{0}&apos; to UTF-8 with byte order mark.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources.SA1413CodeFix">
            <summary>
              Looks up a localized string similar to Add trailing comma.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources.SA1413Description">
            <summary>
              Looks up a localized string similar to A multi-line initializer in a C# code file must use a comma on the last line..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources.SA1413MessageFormat">
            <summary>
              Looks up a localized string similar to Use trailing comma in multi-line initializers.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources.SA1413Title">
            <summary>
              Looks up a localized string similar to Use trailing comma in multi-line initializers.
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1119StatementMustNotUseUnnecessaryParenthesis">
             <summary>
             A C# statement contains parenthesis which are unnecessary and should be removed.
             </summary>
             <remarks>
             <para>It is possible in C# to insert parenthesis around virtually any type of expression, statement, or clause,
             and in many situations use of parenthesis can greatly improve the readability of the code. However, excessive
             use of parenthesis can have the opposite effect, making it more difficult to read and maintain the code.</para>
            
             <para>A violation of this rule occurs when parenthesis are used in situations where they provide no practical
             value. Typically, this happens anytime the parenthesis surround an expression which does not strictly require
             the use of parenthesis, and the parenthesis expression is located at the root of a statement. For example, the
             following lines of code all contain unnecessary parenthesis which will result in violations of this rule:</para>
            
             <code language="csharp">
             int x = (5 + b);
             string y = (this.Method()).ToString();
             return (x.Value);
             </code>
            
             <para>In each of these statements, the extra parenthesis can be removed without sacrificing the readability of
             the code:</para>
            
             <code language="csharp">
             int x = 5 + b;
             string y = this.Method().ToString();
             return x.Value;
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1119StatementMustNotUseUnnecessaryParenthesis.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1119StatementMustNotUseUnnecessaryParenthesis"/>
            analyzer.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1119StatementMustNotUseUnnecessaryParenthesis.ParenthesesDiagnosticId">
            <summary>
            The ID for the helper diagnostic used to mark the parentheses tokens surrounding the expression with
            <see cref="F:Microsoft.CodeAnalysis.WellKnownDiagnosticTags.Unnecessary"/>.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1119StatementMustNotUseUnnecessaryParenthesis.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1119StatementMustNotUseUnnecessaryParenthesis.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1400AccessModifierMustBeDeclared">
             <summary>
             The access modifier for a C# element has not been explicitly defined.
             </summary>
             <remarks>
             <para>C# allows elements to be defined without an access modifier. Depending upon the type of element, C# will
             automatically assign an access level to the element in this case.</para>
            
             <para>This rule requires an access modifier to be explicitly defined for every element. This removes the need
             for the reader to make assumptions about the code, improving the readability of the code.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1400AccessModifierMustBeDeclared.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1400AccessModifierMustBeDeclared"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1400AccessModifierMustBeDeclared.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1400AccessModifierMustBeDeclared.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1401FieldsMustBePrivate">
             <summary>
             A field within a C# class has an access modifier other than private.
             </summary>
             <remarks>
             <para>A violation of this rule occurs whenever a field in a class is given non-private access. For
             maintainability reasons, properties should always be used as the mechanism for exposing fields outside of a
             class, and fields should always be declared with private access. This allows the internal implementation of the
             property to change over time without changing the interface of the class.</para>
            
             <para>Fields located within C# structs are allowed to have any access level.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1401FieldsMustBePrivate.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1401FieldsMustBePrivate"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1401FieldsMustBePrivate.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1401FieldsMustBePrivate.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1402FileMayOnlyContainASingleClass">
             <summary>
             A C# code file contains more than one unique class.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when a C# file contains more than one class. To increase long-term
             maintainability of the code-base, each class should be placed in its own file, and file names should reflect the
             name of the class within the file.</para>
            
             <para>It is possible to place other supporting elements within the same file as the class, such as delegates,
             enums, etc., if they are related to the class.</para>
            
             <para>It is also possible to place multiple parts of the same partial class within the same file.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1402FileMayOnlyContainASingleClass.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1402FileMayOnlyContainASingleClass"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1402FileMayOnlyContainASingleClass.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1402FileMayOnlyContainASingleClass.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1403FileMayOnlyContainASingleNamespace">
            <summary>
            A C# code file contains more than one namespace.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when a C# file contains more than one namespace. To increase long-term
            maintainability of the code-base, each file should contain at most one namespace.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1403FileMayOnlyContainASingleNamespace.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1403FileMayOnlyContainASingleNamespace"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1403FileMayOnlyContainASingleNamespace.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1403FileMayOnlyContainASingleNamespace.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1404CodeAnalysisSuppressionMustHaveJustification">
             <summary>
             A Code Analysis SuppressMessage attribute does not include a justification.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the code contains a Code Analysis
             <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute"/> attribute, but a justification for the suppression has not been provided
             within the attribute. Whenever a Code Analysis rule is suppressed, a justification should be provided. This can
             increase the long-term maintainability of the code.</para>
            
             <code language="csharp">
             [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", Justification = "Used during unit testing")]
             public bool Enable()
             {
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1404CodeAnalysisSuppressionMustHaveJustification.JustificationPlaceholder">
            <summary>
            The placeholder to insert as part of the code fix.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1404CodeAnalysisSuppressionMustHaveJustification.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1404CodeAnalysisSuppressionMustHaveJustification"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1404CodeAnalysisSuppressionMustHaveJustification.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1404CodeAnalysisSuppressionMustHaveJustification.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1404CodeAnalysisSuppressionMustHaveJustification.AnalyzerInstance">
            <summary>
            This class holds analyzer state information for analysis within a particular <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1404CodeAnalysisSuppressionMustHaveJustification.AnalyzerInstance.suppressMessageAttribute">
            <summary>
            A lazily-initialized reference to <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute"/> within the context of a
            particular <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1405DebugAssertMustProvideMessageText">
             <summary>
             A call to <see cref="O:System.Diagnostics.Debug.Assert"/> in C# code does not include a descriptive message.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the code contains a call to
             <see cref="O:System.Diagnostics.Debug.Assert"/> which does not provide a description for the end-user. For
             example, the following assert includes a description message:</para>
            
             <code language="csharp">
             Debug.Assert(value != true, "The value must always be true.");
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1405DebugAssertMustProvideMessageText.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1405DebugAssertMustProvideMessageText"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1405DebugAssertMustProvideMessageText.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1405DebugAssertMustProvideMessageText.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1406DebugFailMustProvideMessageText">
             <summary>
             A call to <see cref="O:System.Diagnostics.Debug.Fail"/> in C# code does not include a descriptive message.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the code contains a call to
             <see cref="O:System.Diagnostics.Debug.Fail"/> which does not provide a description for the end-user. For
             example, the following call includes a description message:</para>
            
             <code language="csharp">
             Debug.Fail("The code should never reach this point.");
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1406DebugFailMustProvideMessageText.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1406DebugFailMustProvideMessageText"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1406DebugFailMustProvideMessageText.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1406DebugFailMustProvideMessageText.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1407ArithmeticExpressionsMustDeclarePrecedence">
             <summary>
             A C# statement contains a complex arithmetic expression which omits parenthesis around operators.
             </summary>
             <remarks>
             <para>C# maintains a hierarchy of precedence for arithmetic operators. It is possible in C# to string multiple
             arithmetic operations together in one statement without wrapping any of the operations in parenthesis, in which
             case the compiler will automatically set the order and precedence of the operations based on these
             pre-established rules. For example:</para>
            
             <code language="csharp">
             int x = 5 + y * b / 6 % z - 2;
             </code>
            
             <para>Although this code is legal, it is not highly readable or maintainable. In order to achieve full
             understanding of this code, the developer must know and understand the basic operator precedence rules in
             C#.</para>
            
             <para>This rule is intended to increase the readability and maintainability of this type of code, and to reduce
             the risk of introducing bugs later, by forcing the developer to insert parenthesis to explicitly declare the
             operator precedence. The example below shows multiple arithmetic operations surrounded by parenthesis:</para>
            
             <code language="csharp">
             int x = 5 + (y * ((b / 6) % z)) - 2;
             </code>
            
             <para>Inserting parenthesis makes the code more obvious and easy to understand, and removes the need for the
             reader to make assumptions about the code.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1407ArithmeticExpressionsMustDeclarePrecedence.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1407ArithmeticExpressionsMustDeclarePrecedence"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1407ArithmeticExpressionsMustDeclarePrecedence.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1407ArithmeticExpressionsMustDeclarePrecedence.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1408ConditionalExpressionsMustDeclarePrecedence">
             <summary>
             A C# statement contains a complex conditional expression which omits parenthesis around operators.
             </summary>
             <remarks>
             <para>C# maintains a hierarchy of precedence for conditional operators. It is possible in C# to string multiple
             conditional operations together in one statement without wrapping any of the operations in parenthesis, in which
             case the compiler will automatically set the order and precedence of the operations based on these
             pre-established rules. For example:</para>
            
             <code language="csharp">
             if (x || y &amp;&amp; z &amp;&amp; a || b)
             {
             }
             </code>
            
             <para>Although this code is legal, it is not highly readable or maintainable. In order to achieve full
             understanding of this code, the developer must know and understand the basic operator precedence rules in
             C#.</para>
            
             <para>This rule is intended to increase the readability and maintainability of this type of code, and to reduce
             the risk of introducing bugs later, by forcing the developer to insert parenthesis to explicitly declare the
             operator precedence. For example, a developer could write this code as:</para>
            
             <code language="csharp">
             if ((x || y) &amp;&amp; z &amp;&amp; (a || b))
             {
             }
             </code>
            
             <para>or</para>
            
             <code language="csharp">
             if (x || (y &amp;&amp; z &amp;&amp; a) || b)
             {
             }
             </code>
            
             <para>Inserting parenthesis makes the code more obvious and easy to understand, and removes the need for the
             reader to make assumptions about the code.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1408ConditionalExpressionsMustDeclarePrecedence.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1408ConditionalExpressionsMustDeclarePrecedence"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1408ConditionalExpressionsMustDeclarePrecedence.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1408ConditionalExpressionsMustDeclarePrecedence.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1409RemoveUnnecessaryCode">
             <summary>
             A C# file contains code which is unnecessary and can be removed without changing the overall logic of the code.
             </summary>
             <remarks>
             <para>This diagnostic is not implemented in StyleCopAnalyzers.</para>
            
             <para>A violation of this rule occurs when the file contains code which can be removed without changing the
             overall logic of the code.</para>
            
             <para>For example, the following try-catch statement could be removed completely since the try and catch blocks
             are both empty.</para>
            
             <code language="csharp">
             try
             {
             }
             catch (Exception ex)
             {
             }
             </code>
            
             <para>The try-finally statement below does contain code within the try block, but it does not contain any catch
             blocks, and the finally block is empty. Thus, the try-finally is not performing any useful function and can be
             removed.</para>
            
             <code language="csharp">
             try
             {
                 this.Method();
             }
             finally
             {
             }
             </code>
            
             <para>As a final example, the unsafe statement below is empty, and thus provides no value.</para>
            
             <code language="csharp">
             unsafe
             {
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1409RemoveUnnecessaryCode.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1409RemoveUnnecessaryCode"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1409RemoveUnnecessaryCode.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1409RemoveUnnecessaryCode.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1410RemoveDelegateParenthesisWhenPossible">
             <summary>
             A call to a C# anonymous method does not contain any method parameters, yet the statement still includes
             parenthesis.
             </summary>
             <remarks>
             <para>When an anonymous method does not contain any method parameters, the parenthesis around the parameters are
             optional.</para>
            
             <para>A violation of this rule occurs when the parenthesis are present on an anonymous method call which takes
             no method parameters. For example:</para>
            
             <code language="csharp">
             this.Method(delegate() { return 2; });
             </code>
            
             <para>The parenthesis are unnecessary and should be removed:</para>
            
             <code language="csharp">
             this.Method(delegate { return 2; });
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1410RemoveDelegateParenthesisWhenPossible.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1410RemoveDelegateParenthesisWhenPossible"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1410RemoveDelegateParenthesisWhenPossible.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1410RemoveDelegateParenthesisWhenPossible.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1411AttributeConstructorMustNotUseUnnecessaryParenthesis">
             <summary>
             TODO.
             </summary>
             <remarks>
             <para>TODO</para>
            
             <para>A violation of this rule occurs when unnecessary parenthesis have been used in an attribute constructor.
             For example:</para>
            
             <code language="csharp">
             [Serializable()]
             </code>
             <para>The parenthesis are unnecessary and should be removed:</para>
             <code language="csharp">
             [Serializable]
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1411AttributeConstructorMustNotUseUnnecessaryParenthesis.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1411AttributeConstructorMustNotUseUnnecessaryParenthesis"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1411AttributeConstructorMustNotUseUnnecessaryParenthesis.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1411AttributeConstructorMustNotUseUnnecessaryParenthesis.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1412StoreFilesAsUtf8">
            <summary>
            Store files as UTF-8 with byte order mark.
            </summary>
            <remarks>
            <para>Storing files in this encoding ensures that the files are always treated the same way by the compiler,
            even when compiled on systems with varying default system encodings. In addition,
            this encoding is the most widely supported encoding for features like visual diffs on GitHub and other tooling.
            This encoding is also the default encoding used when creating new C# source files within Visual Studio.
            </para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1412StoreFilesAsUtf8.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1412StoreFilesAsUtf8"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1412StoreFilesAsUtf8.EncodingProperty">
            <summary>
            Gets the key for the detected encoding name in the <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Properties"/> collection.
            </summary>
            <value>
            The key for the detected encoding name in the <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Properties"/> collection.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1412StoreFilesAsUtf8.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1412StoreFilesAsUtf8.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SA1413UseTrailingCommasInMultiLineInitializers">
             <summary>
             A multi-line initializer must use a comma on the last item.
             </summary>
             <remarks>
             <para>The last statement in a multi-line C# initializer is missing a trailing comma.</para>
            
             <para>A violation of this rule occurs when the last statement of a C# initializer is missing a trailing comma.
             For example, the following code would generate one instance of this violation:</para>
            
             <code language="csharp">
             var x = new Barnacle
             {
                 Age = 100,
                 Height = 0.2M,
                 Weight = 0.88M
             };
             </code>
            
             <para>The following code would not produce any violations:</para>
            
             <code language="csharp">
             var x = new Barnacle
             {
                 Age = 100,
                 Height = 0.2M,
                 Weight = 0.88M,
             };
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.MaintainabilityRules.SA1413UseTrailingCommasInMultiLineInitializers.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1413UseTrailingCommasInMultiLineInitializers"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.MaintainabilityRules.SA1413UseTrailingCommasInMultiLineInitializers.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SA1413UseTrailingCommasInMultiLineInitializers.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.MaintainabilityRules.SystemDiagnosticsDebugDiagnosticBase">
            <summary>
            A base class for <see cref="T:System.Diagnostics.Debug"/> diagnostics.
            It is used to share code in diagnostics <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1405DebugAssertMustProvideMessageText"/> and <see cref="T:StyleCop.Analyzers.MaintainabilityRules.SA1406DebugFailMustProvideMessageText"/>
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.MaintainabilityRules.SystemDiagnosticsDebugDiagnosticBase.HandleMethodCall(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.String,System.Int32,Microsoft.CodeAnalysis.DiagnosticDescriptor)">
            <summary>
            Analyzes a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax"/> node to add a diagnostic to static method calls in <see cref="T:System.Diagnostics.Debug"/>.
            The diagnostic is added if the parameter count is lower than <paramref name="parameterIndex"/> or the string given at the index can be evaluated to null, string.Empty or just whitespaces.
            </summary>
            <param name="context">The current analysis context</param>
            <param name="methodName">The method name that should be detected</param>
            <param name="parameterIndex">The index, the string parameter that should be checked, is at</param>
            <param name="descriptor">The descriptor of the diagnostic that should be added</param>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.NamingResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.NamingResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.NamingResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.NamingResources.RenameToCodeFix">
            <summary>
              Looks up a localized string similar to Rename To &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.NamingResources.SA1302CodeFix">
            <summary>
              Looks up a localized string similar to Prefix interface name with &apos;I&apos;.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.NamingResources.SA1312Description">
            <summary>
              Looks up a localized string similar to The name of a variable in C# does not begin with a lower-case letter..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.NamingResources.SA1312MessageFormat">
            <summary>
              Looks up a localized string similar to Variable &apos;{0}&apos; must begin with lower-case letter.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.NamingResources.SA1312Title">
            <summary>
              Looks up a localized string similar to Variable names must begin with lower-case letter.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.NamingResources.SA1313Description">
            <summary>
              Looks up a localized string similar to The name of a parameter in C# does not begin with a lower-case letter..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.NamingResources.SA1313MessageFormat">
            <summary>
              Looks up a localized string similar to Parameter &apos;{0}&apos; must begin with lower-case letter.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.NamingResources.SA1313Title">
            <summary>
              Looks up a localized string similar to Parameter names must begin with lower-case letter.
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SA1300ElementMustBeginWithUpperCaseLetter">
             <summary>
             The name of a C# element does not begin with an upper-case letter.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the names of certain types of elements do not begin with an
             upper-case letter. The following types of elements should use an upper-case letter as the first letter of the
             element name: namespaces, classes, enums, structs, delegates, events, methods, and properties.</para>
            
             <para>In addition, any field which is public, internal, or marked with the const attribute should begin with an
             upper-case letter. Non-private readonly fields must also be named using an upper-case letter.</para>
            
             <para>If the field or variable name is intended to match the name of an item associated with Win32 or COM, and
             thus needs to begin with a lower-case letter, place the field or variable within a special <c>NativeMethods</c>
             class. A <c>NativeMethods</c> class is any class which contains a name ending in <c>NativeMethods</c>, and is
             intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed
             within a <c>NativeMethods</c> class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SA1300ElementMustBeginWithUpperCaseLetter.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SA1300ElementMustBeginWithUpperCaseLetter"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SA1300ElementMustBeginWithUpperCaseLetter.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SA1300ElementMustBeginWithUpperCaseLetter.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SA1301ElementMustBeginWithLowerCaseLetter">
            <summary>
            There are currently no situations in which this rule will fire.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SA1301ElementMustBeginWithLowerCaseLetter.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SA1301ElementMustBeginWithLowerCaseLetter"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SA1301ElementMustBeginWithLowerCaseLetter.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SA1301ElementMustBeginWithLowerCaseLetter.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SA1302InterfaceNamesMustBeginWithI">
             <summary>
             The name of a C# interface does not begin with the capital letter I.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the name of an interface does not begin with the capital letter I.
             Interface names should always begin with I. For example, <c>ICustomer</c>.</para>
            
             <para>If the field or variable name is intended to match the name of an item associated with Win32 or COM, and
             thus cannot begin with the letter I, place the field or variable within a special <c>NativeMethods</c> class. A
             <c>NativeMethods</c> class is any class which contains a name ending in <c>NativeMethods</c>, and is intended as
             a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a
             <c>NativeMethods</c> class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SA1302InterfaceNamesMustBeginWithI.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SA1302InterfaceNamesMustBeginWithI"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SA1302InterfaceNamesMustBeginWithI.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SA1302InterfaceNamesMustBeginWithI.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SA1303ConstFieldNamesMustBeginWithUpperCaseLetter">
             <summary>
             The name of a constant C# field must begin with an upper-case letter.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the name of a field marked with the <c>const</c> attribute does not
             begin with an upper-case letter.</para>
            
             <para>If the field or variable name is intended to match the name of an item associated with Win32 or COM, and
             thus needs to begin with a lower-case letter, place the field or variable within a special <c>NativeMethods</c>
             class. A <c>NativeMethods</c> class is any class which contains a name ending in <c>NativeMethods</c>, and is
             intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed
             within a <c>NativeMethods</c> class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SA1303ConstFieldNamesMustBeginWithUpperCaseLetter.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SA1303ConstFieldNamesMustBeginWithUpperCaseLetter"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SA1303ConstFieldNamesMustBeginWithUpperCaseLetter.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SA1303ConstFieldNamesMustBeginWithUpperCaseLetter.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SA1304NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter">
             <summary>
             The name of a non-private readonly C# field must begin with an upper-case letter.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the name of a readonly field which is not private does not begin with
             an upper-case letter. Non-private readonly fields must always start with an upper-case letter.</para>
            
             <para>If the field or variable name is intended to match the name of an item associated with Win32 or COM, and
             thus needs to begin with a lower-case letter, place the field or variable within a special <c>NativeMethods</c>
             class. A <c>NativeMethods</c> class is any class which contains a name ending in <c>NativeMethods</c>, and is
             intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed
             within a <c>NativeMethods</c> class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SA1304NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.NamingRules.SA1304NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SA1304NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SA1304NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SA1305FieldNamesMustNotUseHungarianNotation">
             <summary>
             The name of a field or variable in C# uses Hungarian notation.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when Hungarian notation is used in the naming of fields and variables. The
             use of Hungarian notation has become widespread in C++ code, but the trend in C# is to use longer, more
             descriptive names for variables, which are not based on the type of the variable but which instead describe what
             the variable is used for.</para>
            
             <para>In addition, modern code editors such as Visual Studio make it easy to identify type information for a
             variable or field, typically by hovering the mouse cursor over the variable name. This reduces the need for
             Hungarian notation.</para>
            
             <para>StyleCop assumes that any variable name that begins with one or two lower-case letters followed by an
             upper-case letter is making use of Hungarian notation, and will flag a violation of this rule in each case. It
             is possible to declare certain prefixes as legal, in which case they will be ignored. For example, a variable
             named <c>onExecute</c> will appear to StyleCop to be using Hungarian notation, when in reality it is not. Thus,
             the <c>on</c> prefix should be flagged as an allowed prefix.</para>
            
             <para>To configure the list of allowed prefixes, bring up the StyleCop settings for a project, and navigate to
             the Hungarian tab, as shown below:</para>
            
             <para><img alt="" src="Images/HungarianSettings.JPG" border="0"/></para>
            
             <para>Adding a one or two letter prefix to this list will cause StyleCop to ignore variables or fields which
             begin with this prefix.</para>
            
             <para>If the field or variable name is intended to match the name of an item associated with Win32 or COM, and
             thus needs to use Hungarian notation, place the field or variable within a special <c>NativeMethods</c> class. A
             <c>NativeMethods</c> class is any class which contains a name ending in <c>NativeMethods</c>, and is intended as
             a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a
             <c>NativeMethods</c> class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SA1305FieldNamesMustNotUseHungarianNotation.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SA1305FieldNamesMustNotUseHungarianNotation"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SA1305FieldNamesMustNotUseHungarianNotation.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SA1305FieldNamesMustNotUseHungarianNotation.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SA1306FieldNamesMustBeginWithLowerCaseLetter">
             <summary>
             The name of a field in C# does not begin with a lower-case letter.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the name of a field begins with an upper-case letter. Constants,
             non-private readonly fields and static readonly fields must always start with an uppercase letter, whilst
             private readonly fields must start with a lowercase letter. Also, public or internal fields must always start
             with an uppercase letter.</para>
            
             <para>If the field name is intended to match the name of an item associated with Win32 or COM, and thus needs to
             begin with an upper-case letter, place the field within a special <c>NativeMethods</c> class. A
             <c>NativeMethods</c> class is any class which contains a name ending in <c>NativeMethods</c>, and is intended as
             a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a
             <c>NativeMethods</c> class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SA1306FieldNamesMustBeginWithLowerCaseLetter.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SA1306FieldNamesMustBeginWithLowerCaseLetter"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SA1306FieldNamesMustBeginWithLowerCaseLetter.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SA1306FieldNamesMustBeginWithLowerCaseLetter.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SA1307AccessibleFieldsMustBeginWithUpperCaseLetter">
             <summary>
             The name of a public or internal field in C# does not begin with an upper-case letter.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the name of a public or internal field begins with a lower-case
             letter. Public or internal fields must being with an upper-case letter.</para>
            
             <para>If the field or variable name is intended to match the name of an item associated with Win32 or COM, and
             thus needs to start with a lower-case letter, place the field or variable within a special <c>NativeMethods</c>
             class. A <c>NativeMethods</c> class is any class which contains a name ending in <c>NativeMethods</c>, and is
             intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed
             within a <c>NativeMethods</c> class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SA1307AccessibleFieldsMustBeginWithUpperCaseLetter.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SA1307AccessibleFieldsMustBeginWithUpperCaseLetter"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SA1307AccessibleFieldsMustBeginWithUpperCaseLetter.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SA1307AccessibleFieldsMustBeginWithUpperCaseLetter.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SA1308VariableNamesMustNotBePrefixed">
             <summary>
             A field name in C# is prefixed with <c>m_</c> or <c>s_</c>.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when a field name is prefixed by <c>m_</c> or <c>s_</c>.</para>
            
             <para>By default, StyleCop disallows the use of underscores, <c>m_</c>, etc., to mark local class fields, in
             favor of the <c>this.</c> prefix. The advantage of using <c>this.</c> is that it applies equally to all element
             types including methods, properties, etc., and not just fields, making all calls to class members instantly
             recognizable, regardless of which editor is being used to view the code. Another advantage is that it creates a
             quick, recognizable differentiation between instance members and static members, which will not be
             prefixed.</para>
            
             <para>If the field or variable name is intended to match the name of an item associated with Win32 or COM, and
             thus needs to begin with the prefix, place the field or variable within a special <c>NativeMethods</c> class. A
             <c>NativeMethods</c> class is any class which contains a name ending in <c>NativeMethods</c>, and is intended as
             a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a
             <c>NativeMethods</c> class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SA1308VariableNamesMustNotBePrefixed.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SA1308VariableNamesMustNotBePrefixed"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SA1308VariableNamesMustNotBePrefixed.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SA1308VariableNamesMustNotBePrefixed.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SA1309FieldNamesMustNotBeginWithUnderscore">
             <summary>
             A field name in C# begins with an underscore.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when a field name begins with an underscore.</para>
            
             <para>By default, StyleCop disallows the use of underscores, <c>m_</c>, etc., to mark local class fields, in
             favor of the <c>this.</c> prefix. The advantage of using <c>this.</c> is that it applies equally to all element
             types including methods, properties, etc., and not just fields, making all calls to class members instantly
             recognizable, regardless of which editor is being used to view the code. Another advantage is that it creates a
             quick, recognizable differentiation between instance members and static members, which will not be
             prefixed.</para>
            
             <para>If the field or variable name is intended to match the name of an item associated with Win32 or COM, and
             thus needs to begin with an underscore, place the field or variable within a special <c>NativeMethods</c> class.
             A <c>NativeMethods</c> class is any class which contains a name ending in <c>NativeMethods</c>, and is intended
             as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a
             <c>NativeMethods</c> class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SA1309FieldNamesMustNotBeginWithUnderscore.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SA1309FieldNamesMustNotBeginWithUnderscore"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SA1309FieldNamesMustNotBeginWithUnderscore.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SA1309FieldNamesMustNotBeginWithUnderscore.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SA1310FieldNamesMustNotContainUnderscore">
             <summary>
             A field name in C# contains an underscore.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when a field name contains an underscore. Fields and variables should be
             named using descriptive, readable wording which describes the function of the field or variable. Typically,
             these names will be written using camel case, and should not use underscores. For example, use
             <c>customerPostCode</c> rather than <c>customer_post_code</c>.</para>
            
             <para>If the field or variable name is intended to match the name of an item associated with Win32 or COM, and
             thus needs to include underscores, place the field or variable within a special <c>NativeMethods</c> class. A
             <c>NativeMethods</c> class is any class which contains a name ending in <c>NativeMethods</c>, and is intended as
             a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a
             <c>NativeMethods</c> class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SA1310FieldNamesMustNotContainUnderscore.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SA1310FieldNamesMustNotContainUnderscore"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SA1310FieldNamesMustNotContainUnderscore.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SA1310FieldNamesMustNotContainUnderscore.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SA1311StaticReadonlyFieldsMustBeginWithUpperCaseLetter">
            <summary>
            The name of a static readonly field does not begin with an upper-case letter.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when the name of a static readonly field begins with a lower-case
            letter.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SA1311StaticReadonlyFieldsMustBeginWithUpperCaseLetter.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SA1311StaticReadonlyFieldsMustBeginWithUpperCaseLetter"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SA1311StaticReadonlyFieldsMustBeginWithUpperCaseLetter.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SA1311StaticReadonlyFieldsMustBeginWithUpperCaseLetter.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SA1312VariableNamesMustBeginWithLowerCaseLetter">
             <summary>
             The name of a variable in C# does not begin with a lower-case letter.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the name of a variable does not begin with a lower-case letter.</para>
            
             <para>If the variable name is intended to match the name of an item associated with Win32 or COM, and thus needs
             to begin with an upper-case letter, place the variable within a special <c>NativeMethods</c> class. A
             <c>NativeMethods</c> class is any class which contains a name ending in <c>NativeMethods</c>, and is intended as
             a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a
             <c>NativeMethods</c> class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SA1312VariableNamesMustBeginWithLowerCaseLetter.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SA1312VariableNamesMustBeginWithLowerCaseLetter"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SA1312VariableNamesMustBeginWithLowerCaseLetter.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SA1312VariableNamesMustBeginWithLowerCaseLetter.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SA1313ParameterNamesMustBeginWithLowerCaseLetter">
             <summary>
             The name of a parameter in C# does not begin with a lower-case letter.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the name of a parameter does not begin with a lower-case letter.</para>
            
             <para>An exception to this rule is made for lambda parameters named <c>_</c>. These parameters are often used to
             designate a placeholder parameter which is not actually used in the body of the lambda expression.</para>
            
             <para>If the parameter name is intended to match the name of an item associated with Win32 or COM, and thus
             needs to begin with an upper-case letter, place the parameter within a special <c>NativeMethods</c> class. A
             <c>NativeMethods</c> class is any class which contains a name ending in <c>NativeMethods</c>, and is intended as
             a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed within a
             <c>NativeMethods</c> class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SA1313ParameterNamesMustBeginWithLowerCaseLetter.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SA1313ParameterNamesMustBeginWithLowerCaseLetter"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SA1313ParameterNamesMustBeginWithLowerCaseLetter.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SA1313ParameterNamesMustBeginWithLowerCaseLetter.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SX1309FieldNamesMustBeginWithUnderscore">
             <summary>
             A field name in C# does not begin with an underscore.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when a field name does not begin with an underscore.</para>
            
             <para>This rule is an alternative to rule <see cref="T:StyleCop.Analyzers.NamingRules.SA1309FieldNamesMustNotBeginWithUnderscore"/> for
             development teams who prefer to prefix fields with an underscore.</para>
            
             <para>If the field or variable name is intended to match the name of an item associated with Win32 or COM, and
             thus needs to not begin with an underscore, place the field or variable within a special <c>NativeMethods</c>
             class. A <c>NativeMethods</c> class is any class which contains a name ending in <c>NativeMethods</c>, and is
             intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed
             within a <c>NativeMethods</c> class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SX1309FieldNamesMustBeginWithUnderscore.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SX1309FieldNamesMustBeginWithUnderscore"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SX1309FieldNamesMustBeginWithUnderscore.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SX1309FieldNamesMustBeginWithUnderscore.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NamingRules.SX1309SStaticFieldNamesMustBeginWithUnderscore">
             <summary>
             A static field name in C# does not begin with an underscore.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when a static field name does not begin with an underscore.</para>
            
             <para>This rule is an alternative to rule <see cref="T:StyleCop.Analyzers.NamingRules.SA1309FieldNamesMustNotBeginWithUnderscore"/> for
             development teams who prefer to prefix static fields with an underscore.</para>
            
             <para>If the field or variable name is intended to match the name of an item associated with Win32 or COM, and
             thus needs to not begin with an underscore, place the field or variable within a special <c>NativeMethods</c>
             class. A <c>NativeMethods</c> class is any class which contains a name ending in <c>NativeMethods</c>, and is
             intended as a placeholder for Win32 or COM wrappers. StyleCop will ignore this violation if the item is placed
             within a <c>NativeMethods</c> class.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.NamingRules.SX1309SStaticFieldNamesMustBeginWithUnderscore.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.NamingRules.SX1309SStaticFieldNamesMustBeginWithUnderscore"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.NamingRules.SX1309SStaticFieldNamesMustBeginWithUnderscore.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.NamingRules.SX1309SStaticFieldNamesMustBeginWithUnderscore.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.NoCodeFixAttribute">
            <summary>
            This attribute is applied to <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>s for which no code fix is currently planned.
            </summary>
            <remarks>
            <para>There are several reasons an analyzer does not have a code fix, including but not limited to the
            following:</para>
            <list type="bullet">
            <item>Visual Studio provides a built-in code fix.</item>
            <item>A code fix could not provide a useful solution.</item>
            </list>
            <para>The <see cref="P:StyleCop.Analyzers.NoCodeFixAttribute.Reason"/> should be provided.</para>
            </remarks>
        </member>
        <member name="M:StyleCop.Analyzers.NoCodeFixAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.NoCodeFixAttribute"/> class.
            </summary>
            <param name="reason">The reason why the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> does not have a code fix.</param>
        </member>
        <member name="P:StyleCop.Analyzers.NoCodeFixAttribute.Reason">
            <summary>
            Gets the reason why the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> does not have a code fix.
            </summary>
            <value>
            The reason why the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> does not have a code fix.
            </value>
        </member>
        <member name="T:StyleCop.Analyzers.NoDiagnosticAttribute">
            <summary>
            This attribute is applied to <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>s for which no implementation is currently planned.
            </summary>
            <remarks>
            <para>There are several reasons an analyzer for a StyleCop diagnostic does not have an implementation, including
            but not limited to the following:</para>
            <list type="bullet">
            <item>Visual Studio provides a built-in diagnostic.</item>
            <item>The diagnostic is vaguely defined, so there is no clear direction for the implementation.</item>
            <item>The diagnostic has been superseded by a fine-grained set of new rules for customization.</item>
            </list>
            <para>The <see cref="P:StyleCop.Analyzers.NoDiagnosticAttribute.Reason"/> should be provided.</para>
            </remarks>
        </member>
        <member name="M:StyleCop.Analyzers.NoDiagnosticAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.NoDiagnosticAttribute"/> class.
            </summary>
            <param name="reason">The reason why the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> does not have an implementation.</param>
        </member>
        <member name="P:StyleCop.Analyzers.NoDiagnosticAttribute.Reason">
            <summary>
            Gets the reason why the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> does not have an implementation.
            </summary>
            <value>
            The reason why the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> does not have an implementation.
            </value>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.RemoveRegionCodeFix">
            <summary>
              Looks up a localized string similar to Remove region.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1100CodeFix">
            <summary>
              Looks up a localized string similar to Replace &apos;base.&apos; with &apos;this.&apos;.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1100Description">
            <summary>
              Looks up a localized string similar to A call to a member from an inherited class begins with &apos;base.&apos;, and the local class does not contain an override or implementation of the member..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1100MessageFormat">
            <summary>
              Looks up a localized string similar to Do not prefix calls with base unless local implementation exists.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1100Title">
            <summary>
              Looks up a localized string similar to Do not prefix calls with base unless local implementation exists.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1101CodeFix">
            <summary>
              Looks up a localized string similar to Prefix reference with &apos;this.&apos;.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1101Description">
            <summary>
              Looks up a localized string similar to A call to an instance member of the local class or a base class is not prefixed with &apos;this.&apos;, within a C# code file..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1101MessageFormat">
            <summary>
              Looks up a localized string similar to Prefix local calls with this.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1101Title">
            <summary>
              Looks up a localized string similar to Prefix local calls with this.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1102CodeFix">
            <summary>
              Looks up a localized string similar to Remove separating lines.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1102Description">
            <summary>
              Looks up a localized string similar to A C# query clause does not begin on the same line as the previous clause, or on the next line..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1102MessageFormat">
            <summary>
              Looks up a localized string similar to Query clause must follow previous clause..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1102Title">
            <summary>
              Looks up a localized string similar to Query clause must follow previous clause.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1103CodeFixMultipleLines">
            <summary>
              Looks up a localized string similar to Place on multiple lines.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1103CodeFixSingleLine">
            <summary>
              Looks up a localized string similar to Place on single line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1103Description">
            <summary>
              Looks up a localized string similar to The clauses within a C# query expression are not all placed on the same line, and each clause is not placed on its own line..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1103MessageFormat">
            <summary>
              Looks up a localized string similar to Query clauses must be on separate lines or all on one line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1103Title">
            <summary>
              Looks up a localized string similar to Query clauses must be on separate lines or all on one line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1104Description">
            <summary>
              Looks up a localized string similar to A clause within a C# query expression begins on the same line as the previous clause, when the previous clause spans across multiple lines..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1104MessageFormat">
            <summary>
              Looks up a localized string similar to Query clause must begin on new line when previous clause spans multiple lines.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1104SA1105CodeFix">
            <summary>
              Looks up a localized string similar to Insert new line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1104Title">
            <summary>
              Looks up a localized string similar to Query clause must begin on new line when previous clause spans multiple lines.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1105Description">
            <summary>
              Looks up a localized string similar to A clause within a C# query expression spans across multiple lines, and does not begin on its own line..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1105MessageFormat">
            <summary>
              Looks up a localized string similar to Query clauses spanning multiple lines must begin on own line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1105Title">
            <summary>
              Looks up a localized string similar to Query clauses spanning multiple lines must begin on own line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1106CodeFix">
            <summary>
              Looks up a localized string similar to Remove empty statement.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1106Description">
            <summary>
              Looks up a localized string similar to The C# code contains an extra semicolon..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1106MessageFormat">
            <summary>
              Looks up a localized string similar to Code must not contain empty statements.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1106Title">
            <summary>
              Looks up a localized string similar to Code must not contain empty statements.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1107CodeFix">
            <summary>
              Looks up a localized string similar to Enter new line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1107Description">
            <summary>
              Looks up a localized string similar to The C# code contains more than one statement on a single line..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1107MessageFormat">
            <summary>
              Looks up a localized string similar to Code must not contain multiple statements on one line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1107Title">
            <summary>
              Looks up a localized string similar to Code must not contain multiple statements on one line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1108Description">
            <summary>
              Looks up a localized string similar to A C# statement contains a comment between the declaration of the statement and the opening brace of the statement..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1108MessageFormat">
            <summary>
              Looks up a localized string similar to Block statements must not contain embedded comments.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1108Title">
            <summary>
              Looks up a localized string similar to Block statements must not contain embedded comments.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1109Description">
            <summary>
              Looks up a localized string similar to A C# statement contains a region tag between the declaration of the statement and the opening brace of the statement..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1109MessageFormat">
            <summary>
              Looks up a localized string similar to .
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1109Title">
            <summary>
              Looks up a localized string similar to Block statements must not contain embedded regions.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1110Description">
            <summary>
              Looks up a localized string similar to The opening parenthesis or bracket is not placed on the same line as the method/indexer/attribute/array name..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1110MessageFormat">
            <summary>
              Looks up a localized string similar to Opening parenthesis or bracket must be on declaration line..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1110Title">
            <summary>
              Looks up a localized string similar to Opening parenthesis or bracket must be on declaration line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1111Description">
            <summary>
              Looks up a localized string similar to The closing parenthesis or bracket in a call to or declaration of a C# method/indexer/attribute/array/constructor/delegate is not placed on the same line as the last parameter..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1111MessageFormat">
            <summary>
              Looks up a localized string similar to Closing parenthesis must be on line of last parameter.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1111Title">
            <summary>
              Looks up a localized string similar to Closing parenthesis must be on line of last parameter.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1112Description">
            <summary>
              Looks up a localized string similar to The closing parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or indexer, is not placed on the same line as the opening bracket when the element does not take any parameters..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1112MessageFormat">
            <summary>
              Looks up a localized string similar to Closing parenthesis must be on line of opening parenthesis.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1112Title">
            <summary>
              Looks up a localized string similar to Closing parenthesis must be on line of opening parenthesis.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1113Description">
            <summary>
              Looks up a localized string similar to A comma between two parameters in a call to a C# method or indexer, or in the declaration of a method or indexer, is not placed on the same line as the previous parameter..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1113MessageFormat">
            <summary>
              Looks up a localized string similar to Comma must be on the same line as previous parameter..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1113Title">
            <summary>
              Looks up a localized string similar to Comma must be on the same line as previous parameter.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1114Description">
            <summary>
              Looks up a localized string similar to The start of the parameter list for a method/constructor/indexer/array/operator call or declaration does not begin on the same line as the opening bracket, or on the line after the opening bracket..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1114MessageFormat">
            <summary>
              Looks up a localized string similar to Parameter list must follow declaration.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1114Title">
            <summary>
              Looks up a localized string similar to Parameter list must follow declaration.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1115Description">
            <summary>
              Looks up a localized string similar to A parameter within a C# method or indexer call or declaration does not begin on the same line as the previous parameter, or on the next line..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1115MessageFormat">
            <summary>
              Looks up a localized string similar to The parameter must begin on the line after the previous parameter..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1115Title">
            <summary>
              Looks up a localized string similar to Parameter must follow comma.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1116CodeFix">
            <summary>
              Looks up a localized string similar to Move first argument to next line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1116Description">
            <summary>
              Looks up a localized string similar to The parameters to a C# method or indexer call or declaration span across multiple lines, but the first parameter does not start on the line after the opening bracket..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1116MessageFormat">
            <summary>
              Looks up a localized string similar to The parameters must begin on the line after the declaration, whenever the parameter span across multiple lines.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1116Title">
            <summary>
              Looks up a localized string similar to Split parameters must start on line after declaration.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1117Description">
            <summary>
              Looks up a localized string similar to The parameters to a C# method or indexer call or declaration are not all on the same line or each on a separate line..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1117MessageFormat">
            <summary>
              Looks up a localized string similar to The parameters must all be placed on the same line or each parameter must be placed on its own line..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1117Title">
            <summary>
              Looks up a localized string similar to Parameters must be on same line or separate lines.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1118Description">
            <summary>
              Looks up a localized string similar to A parameter to a C# method/indexer/attribute/array, other than the first parameter, spans across multiple lines. If the parameter is short, place the entire parameter on a single line. Otherwise, save the contents of the parameter in a temporary variable and pass the temporary variable as a parameter..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1118MessageFormat">
            <summary>
              Looks up a localized string similar to The parameter spans multiple lines.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1118Title">
            <summary>
              Looks up a localized string similar to Parameter must not span multiple lines.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1120CodeFix">
            <summary>
              Looks up a localized string similar to Remove empty comment.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1120Description">
            <summary>
              Looks up a localized string similar to The C# comment does not contain any comment text..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1120MessageFormat">
            <summary>
              Looks up a localized string similar to Comments must contain text.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1120Title">
            <summary>
              Looks up a localized string similar to Comments must contain text.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1121CodeFix">
            <summary>
              Looks up a localized string similar to Replace with built-in type.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1121Description">
            <summary>
              Looks up a localized string similar to The code uses one of the basic C# types, but does not use the built-in alias for the type..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1121MessageFormat">
            <summary>
              Looks up a localized string similar to Use built-in type alias.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1121Title">
            <summary>
              Looks up a localized string similar to Use built-in type alias.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1122CodeFix">
            <summary>
              Looks up a localized string similar to Replace with string.Empty.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1122Description">
            <summary>
              Looks up a localized string similar to The C# code includes an empty string, written as &quot;&quot;..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1122MessageFormat">
            <summary>
              Looks up a localized string similar to Use string.Empty for empty strings.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1122Title">
            <summary>
              Looks up a localized string similar to Use string.Empty for empty strings.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1123Description">
            <summary>
              Looks up a localized string similar to The C# code contains a region within the body of a code element..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1123MessageFormat">
            <summary>
              Looks up a localized string similar to Region must not be located within a code element..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1123Title">
            <summary>
              Looks up a localized string similar to Do not place regions within elements.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1124Description">
            <summary>
              Looks up a localized string similar to The C# code contains a region..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1124MessageFormat">
            <summary>
              Looks up a localized string similar to Do not use regions.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1124Title">
            <summary>
              Looks up a localized string similar to Do not use regions.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1125Description">
            <summary>
              Looks up a localized string similar to The Nullable&lt;T&gt; type has been defined not using the C# shorthand. For example, Nullable&lt;DateTime&gt; has been used instead of the preferred DateTime?.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1125MessageFormat">
            <summary>
              Looks up a localized string similar to Use shorthand for nullable types.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1125Title">
            <summary>
              Looks up a localized string similar to Use shorthand for nullable types.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1126Description">
            <summary>
              Looks up a localized string similar to A call to a member is not prefixed with the &apos;this.&apos;, &apos;base.&apos;, &apos;object.&apos; or &apos;typename.&apos; prefix to indicate the intended method call, within a C# code file..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1126MessageFormat">
            <summary>
              Looks up a localized string similar to .
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1126Title">
            <summary>
              Looks up a localized string similar to Prefix calls correctly.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1127CodeFix">
            <summary>
              Looks up a localized string similar to Place each type constraint on a new line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1127Description">
            <summary>
              Looks up a localized string similar to Each type constraint clause for a generic type parameter should be listed on a line of code by itself..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1127MessageFormat">
            <summary>
              Looks up a localized string similar to Generic type constraints must be on their own line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1127Title">
            <summary>
              Looks up a localized string similar to Generic type constraints must be on their own line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1128CodeFix">
            <summary>
              Looks up a localized string similar to Place constructor initializer on own line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1128Description">
            <summary>
              Looks up a localized string similar to A constructor initializer, including the colon character, should be on its own line..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1128MessageFormat">
            <summary>
              Looks up a localized string similar to Put constructor initializers on their own line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1128Title">
            <summary>
              Looks up a localized string similar to Put constructor initializers on their own line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1129CodeFix">
            <summary>
              Looks up a localized string similar to Replace with default(T).
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1129Description">
            <summary>
              Looks up a localized string similar to When creating a new instance of a value type T, the syntax &apos;default(T)&apos; is functionally equivalent to the syntax &apos;new T()&apos;. To avoid confusion regarding the behavior of the resulting instance, the first form is preferred..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1129MessageFormat">
            <summary>
              Looks up a localized string similar to Do not use default value type constructor.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1129Title">
            <summary>
              Looks up a localized string similar to Do not use default value type constructor.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1130CodeFix">
            <summary>
              Looks up a localized string similar to Replace with lambda..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1130Description">
            <summary>
              Looks up a localized string similar to Lambda expressions are more succinct and easier to read than anonymous methods, so they should are preferred whenever the two are functionally equivalent..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1130MessageFormat">
            <summary>
              Looks up a localized string similar to Use lambda syntax.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1130Title">
            <summary>
              Looks up a localized string similar to Use lambda syntax.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1131CodeFix">
            <summary>
              Looks up a localized string similar to Swap operands.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1131Description">
            <summary>
              Looks up a localized string similar to When a comparison is made between a variable and a literal, the variable should be placed on the left-hand-side to maximize readability..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1131MessageFormat">
            <summary>
              Looks up a localized string similar to Constant values should appear on the right-hand side of comparisons.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1131Title">
            <summary>
              Looks up a localized string similar to Use readable conditions.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1132CodeFix">
            <summary>
              Looks up a localized string similar to Place each field on a new line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1132Description">
            <summary>
              Looks up a localized string similar to Each field should be declared on its own line, in order to clearly see each field of a type and allow for proper documentation of the behavior of each field..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1132MessageFormat">
            <summary>
              Looks up a localized string similar to Each field should be declared on its own line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1132Title">
            <summary>
              Looks up a localized string similar to Do not combine fields.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1133CodeFix">
            <summary>
              Looks up a localized string similar to Give each attribute its own square brackets.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1133Description">
            <summary>
              Looks up a localized string similar to Each attribute usage should be placed in its own set of square brackets for maximum readability..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1133MessageFormat">
            <summary>
              Looks up a localized string similar to Each attribute should be placed in its own set of square brackets..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1133Title">
            <summary>
              Looks up a localized string similar to Do not combine attributes.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1134CodeFix">
            <summary>
              Looks up a localized string similar to Place attribute on own line..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1134Description">
            <summary>
              Looks up a localized string similar to Each attribute should be placed on its own line of code..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1134MessageFormat">
            <summary>
              Looks up a localized string similar to Each attribute should be placed on its own line of code..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1134Title">
            <summary>
              Looks up a localized string similar to Attributes must not share line.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1136CodeFix">
            <summary>
              Looks up a localized string similar to Place enum values own their own lines.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1136Description">
            <summary>
              Looks up a localized string similar to Enum values should be placed on their own lines for maximum readability..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1136MessageFormat">
            <summary>
              Looks up a localized string similar to Enum values should be on separate lines.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SA1136Title">
            <summary>
              Looks up a localized string similar to Enum values should be on separate lines.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SX1101CodeFix">
            <summary>
              Looks up a localized string similar to Remove &apos;this.&apos; prefix.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SX1101Description">
            <summary>
              Looks up a localized string similar to A call to an instance member of the local class or a base class is prefixed with `this.`..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SX1101MessageFormat">
            <summary>
              Looks up a localized string similar to Do not prefix local calls with &apos;this.&apos;.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.ReadabilityResources.SX1101Title">
            <summary>
              Looks up a localized string similar to Do not prefix local calls with &apos;this.&apos;.
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1100DoNotPrefixCallsWithBaseUnlessLocalImplementationExists">
             <summary>
             A call to a member from an inherited class begins with <c>base.</c>, and the local class does not contain an
             override or implementation of the member.
             </summary>
             <remarks>
             <para>A violation of this rule occurs whenever the code contains a call to a member from the base class prefixed
             with <c>base.</c>, and there is no local implementation of the member. For example:</para>
            
             <code language="cs">
             string name = base.JoinName("John", "Doe");
             </code>
            
             <para>This rule is in place to prevent a potential source of bugs.Consider a base class which contains the
             following virtual method:</para>
            
             <code language="cs">
             public virtual string JoinName(string first, string last)
             {
             }
             </code>
            
             <para>Another class inherits from this base class but does not provide a local override of this method.
             Somewhere within this class, the base class method is called using <c>base.JoinName(...)</c>. This works as
             expected. At a later date, someone adds a local override of this method to the class:</para>
            
             <code language="cs">
             public override string JoinName(string first, string last)
             {
               return “Bob”;
             }
             </code>
            
             <para>At this point, the local call to <c>base.JoinName(...)</c> most likely introduces a bug into the code.
             This call will always call the base class method and will cause the local override to be ignored.</para>
            
             <para>For this reason, calls to members from a base class should not begin with <c>base.</c>, unless a local
             override is implemented, and the developer wants to specifically call the base class member. When there is no
             local override of the base class member, the call should be prefixed with <c>this.</c> rather than
             <c>base.</c>.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1100DoNotPrefixCallsWithBaseUnlessLocalImplementationExists.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1100DoNotPrefixCallsWithBaseUnlessLocalImplementationExists"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1100DoNotPrefixCallsWithBaseUnlessLocalImplementationExists.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1100DoNotPrefixCallsWithBaseUnlessLocalImplementationExists.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1101PrefixLocalCallsWithThis">
             <summary>
             A call to an instance member of the local class or a base class is not prefixed with ‘this.’, within a C# code
             file.
             </summary>
             <remarks>
             <para>A violation of this rule occurs whenever the code contains a call to an instance member of the local class
             or a base class which is not prefixed with <c>this.</c>. An exception to this rule occurs when there is a local
             override of a base class member, and the code intends to call the base class member directly, bypassing the
             local override. In this case the call can be prefixed with <c>base.</c> rather than <c>this.</c>.</para>
            
             <para>By default, StyleCop disallows the use of underscores or <c>m_</c> to mark local class fields, in favor of
             the <c>this.</c> prefix. The advantage of using <c>this.</c> is that it applies equally to all element types
             including methods, properties, etc., and not just fields, making all calls to class members instantly
             recognizable, regardless of which editor is being used to view the code. Another advantage is that it creates a
             quick, recognizable differentiation between instance members and static members, which are not prefixed.</para>
            
             <para>A final advantage of using the <c>this.</c> prefix is that typing <c>this.</c> will cause Visual Studio to
             show the IntelliSense pop-up, making it quick and easy for the developer to choose the class member to
             call.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1101PrefixLocalCallsWithThis.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1101PrefixLocalCallsWithThis"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1101PrefixLocalCallsWithThis.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1101PrefixLocalCallsWithThis.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1101PrefixLocalCallsWithThis.HandleMemberAccessExpression(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext)">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SimpleMemberAccessExpression"/> is handled separately so only <c>X</c> is evaluated in
            the expression <c>X.Y.Z.A.B.C</c>.
            </summary>
            <param name="context">The analysis context for a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.</param>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1106CodeMustNotContainEmptyStatements">
            <summary>
            The C# code contains an extra semicolon.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when the code contain an extra semicolon. Syntactically, this results in
            an extra, empty statement in the code.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1106CodeMustNotContainEmptyStatements.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1106CodeMustNotContainEmptyStatements"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1106CodeMustNotContainEmptyStatements.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1106CodeMustNotContainEmptyStatements.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1107CodeMustNotContainMultipleStatementsOnOneLine">
            <summary>
            The C# code contains more than one statement on a single line.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when the code contain more than one statement on the same line. Each
            statement must begin on a new line.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1107CodeMustNotContainMultipleStatementsOnOneLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1107CodeMustNotContainMultipleStatementsOnOneLine"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1107CodeMustNotContainMultipleStatementsOnOneLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1107CodeMustNotContainMultipleStatementsOnOneLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1108BlockStatementsMustNotContainEmbeddedComments">
             <summary>
             A C# statement contains a comment between the declaration of the statement and the opening brace of the
             statement.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the code contains a comment in between the declaration and the
             opening brace. For example:</para>
             <code language="csharp">
             if (x != y)
             // Make sure x does not equal y
             {
             }
             </code>
             <para>The comment can legally be placed above the statement, or within the body of the statement:</para>
             <code language="csharp">
             // Make sure x does not equal y
             if (x != y)
             {
             }
            
             if (x != y)
             {
                 // Make sure x does not equal y
             }
             </code>
             <para>If the comment is being used to comment out a line of code, begin the comment with four forward slashes
             rather than two:</para>
             <code language="csharp">
             if (x != y)
             ////if (x == y)
             {
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1108BlockStatementsMustNotContainEmbeddedComments.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1108BlockStatementsMustNotContainEmbeddedComments"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1108BlockStatementsMustNotContainEmbeddedComments.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1108BlockStatementsMustNotContainEmbeddedComments.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1109BlockStatementsMustNotContainEmbeddedRegions">
             <summary>
             A C# statement contains a region tag between the declaration of the statement and the opening brace of the
             statement.
             </summary>
             <remarks>
             <para>This diagnostic is not implemented in StyleCopAnalyzers.</para>
            
             <para>A violation of this rule occurs when the code contains a region tag in between the declaration and the
             opening brace. For example:</para>
             <code language="csharp">
             if (x != y)
             #region
             {
             }
             #endregion
             </code>
             <para>This will result in the body of the statement being hidden when the region is collapsed.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1109BlockStatementsMustNotContainEmbeddedRegions.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1109BlockStatementsMustNotContainEmbeddedRegions"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1109BlockStatementsMustNotContainEmbeddedRegions.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1109BlockStatementsMustNotContainEmbeddedRegions.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA110xQueryClauses">
            <summary>
            This analyzer will analyze several diagnostics related to query expressions.
            </summary>
            <seealso href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1102.md">SA1102 Query clause must follow previous clause</seealso>
            <seealso href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1103.md">SA1103 Query clauses must be on separate lines or all on one line</seealso>
            <seealso href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1104.md">SA1104 Query clause must begin on new line when previous clause spans multiple lines</seealso>
            <seealso href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1105.md">SA1105 Query clauses spanning multiple lines must begin on own line</seealso>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA110xQueryClauses.SA1102Descriptor">
            <summary>
            Gets the diagnostic descriptor for SA1102.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1102.</value>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA110xQueryClauses.SA1103Descriptor">
            <summary>
            Gets the diagnostic descriptor for SA1103.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1103.</value>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA110xQueryClauses.SA1104Descriptor">
            <summary>
            Gets the diagnostic descriptor for SA1104.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1104.</value>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA110xQueryClauses.SA1105Descriptor">
            <summary>
            Gets the diagnostic descriptor for SA1105.
            </summary>
            <value>The <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> for SA1105.</value>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA110xQueryClauses.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA110xQueryClauses.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1110OpeningParenthesisMustBeOnDeclarationLine">
             <summary>
             The opening parenthesis or brace in a call to a C# method or indexer, or the declaration of a method or
             indexer, is not placed on the same line as the method or indexer name.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the opening brace of a method or indexer call or declaration is not
             placed on the same line as the method or indexer. The following examples show correct placement of the opening
             brace:</para>
             <code language="csharp">
             public string JoinName(string first, string last)
             {
                 return JoinStrings(
                     first, last);
             }
            
             public int this[int x]
             {
                 get { return this.items[x]; }
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1110OpeningParenthesisMustBeOnDeclarationLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1110OpeningParenthesisMustBeOnDeclarationLine"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1110OpeningParenthesisMustBeOnDeclarationLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1110OpeningParenthesisMustBeOnDeclarationLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1111ClosingParenthesisMustBeOnLineOfLastParameter">
             <summary>
             The closing parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or
             indexer, is not placed on the same line as the last parameter.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the closing bracket of a method or indexer call or declaration is not
             placed on the same line as the last parameter. The following examples show correct placement of the
             bracket:</para>
             <code language="csharp">
             public string JoinName(string first, string last)
             {
                 string name = JoinStrings(
                     first,
                     last);
             }
            
             public int this[int x]
             {
                 get { return this.items[x]; }
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1111ClosingParenthesisMustBeOnLineOfLastParameter.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1111ClosingParenthesisMustBeOnLineOfLastParameter"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1111ClosingParenthesisMustBeOnLineOfLastParameter.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1111ClosingParenthesisMustBeOnLineOfLastParameter.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1112ClosingParenthesisMustBeOnLineOfOpeningParenthesis">
            <summary>
            The closing parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or
            indexer, is not placed on the same line as the opening bracket when the element does not take any parameters.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when a method or indexer does not take any parameters and the closing
            bracket of a call or declaration for the method or indexer is not placed on the same line as the opening
            bracket. The following example shows correct placement of the closing parenthesis:</para>
            <code language="csharp">
            public string GetName()
            {
                return this.name.Trim();
            }
            </code>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1112ClosingParenthesisMustBeOnLineOfOpeningParenthesis.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1112ClosingParenthesisMustBeOnLineOfOpeningParenthesis"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1112ClosingParenthesisMustBeOnLineOfOpeningParenthesis.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1112ClosingParenthesisMustBeOnLineOfOpeningParenthesis.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1113CommaMustBeOnSameLineAsPreviousParameter">
             <summary>
             A comma between two parameters in a call to a C# method or indexer, or in the declaration of a method or
             indexer, is not placed on the same line as the previous parameter.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when a comma between two parameters to a method or indexer is not placed
             on the same line as the previous parameter. The following examples show correct placement of the comma:</para>
             <code language="csharp">
             public string JoinName(string first, string last)
             {
                 string name = JoinStrings(
                     first,
                     last);
             }
            
             public int this[int x,
                int y]
             {
                 get { return this.items[x, y]; }
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1113CommaMustBeOnSameLineAsPreviousParameter.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1113CommaMustBeOnSameLineAsPreviousParameter"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1113CommaMustBeOnSameLineAsPreviousParameter.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1113CommaMustBeOnSameLineAsPreviousParameter.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1114ParameterListMustFollowDeclaration">
             <summary>
             The start of the parameter list for a method or indexer call or declaration does not begin on the same line as
             the opening bracket, or on the line after the opening bracket.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when there are one or more blank lines between the opening bracket and the
             start of the parameter list. For example:</para>
             <code language="csharp">
             public string JoinName(
            
                 string first, string last)
             {
             }
             </code>
             <para>The parameter list must begin on the same line as the opening bracket, or on the next line. For
             example:</para>
             <code language="csharp">
             public string JoinName(string first, string last)
             {
             }
            
             public string JoinName(
                 string first, string last)
             {
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1114ParameterListMustFollowDeclaration.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1114ParameterListMustFollowDeclaration"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1114ParameterListMustFollowDeclaration.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1114ParameterListMustFollowDeclaration.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1115ParameterMustFollowComma">
             <summary>
             A parameter within a C# method or indexer call or declaration does not begin on the same line as the previous
             parameter, or on the next line.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when there are one or more blank lines between a parameter and the
             previous parameter. For example:</para>
             <code language="csharp">
             public string JoinName(
                 string first,
            
                 string last)
             {
             }
             </code>
             <para>The parameter must begin on the same line as the previous comma, or on the next line. For example:</para>
             <code language="csharp">
             public string JoinName(string first, string last)
             {
             }
            
             public string JoinName(
                 string first,
                 string last)
             {
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1115ParameterMustFollowComma.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1115ParameterMustFollowComma"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1115ParameterMustFollowComma.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1115ParameterMustFollowComma.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1116SplitParametersMustStartOnLineAfterDeclaration">
            <summary>
            The parameters to a C# method or indexer call or declaration span across multiple lines, but the first parameter
            does not start on the line after the opening bracket.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when the parameters to a method or indexer span across multiple lines, but
            the first parameter does not start on the line after the opening bracket. For example:</para>
            <code language="csharp">
            public string JoinName(string first,
                string last)
            {
            }
            </code>
            <para>The parameters must begin on the line after the declaration, whenever the parameter span across multiple
            lines:</para>
            <code language="csharp">
            public string JoinName(
                string first,
                string last)
            {
            }
            </code>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1116SplitParametersMustStartOnLineAfterDeclaration.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1116SplitParametersMustStartOnLineAfterDeclaration"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1116SplitParametersMustStartOnLineAfterDeclaration.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1116SplitParametersMustStartOnLineAfterDeclaration.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1117ParametersMustBeOnSameLineOrSeparateLines">
             <summary>
             The parameters to a C# method or indexer call or declaration are not all on the same line or each on a separate
             line.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the parameters to a method or indexer are not all on the same line or
             each on its own line. For example:</para>
             <code language="csharp">
             public string JoinName(string first, string middle,
                 string last)
             {
             }
             </code>
             <para>The parameters can all be placed on the same line:</para>
             <code language="csharp">
             public string JoinName(string first, string middle, string last)
             {
             }
            
             public string JoinName(
                 string first, string middle, string last)
             {
             }
             </code>
             <para>Alternatively, each parameter can be placed on its own line:</para>
             <code language="csharp">
             public string JoinName(
                 string first,
                 string middle,
                 string last)
             {
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1117ParametersMustBeOnSameLineOrSeparateLines.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1117ParametersMustBeOnSameLineOrSeparateLines"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1117ParametersMustBeOnSameLineOrSeparateLines.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1117ParametersMustBeOnSameLineOrSeparateLines.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1118ParameterMustNotSpanMultipleLines">
             <summary>
             A parameter to a C# method or indexer, other than the first parameter, spans across multiple lines.
             </summary>
             <remarks>
             <para>To prevent method calls from becoming excessively complicated and unreadable, only the first parameter to
             a method or indexer call is allowed to span across multiple lines. The exception is an anonymous method passed
             as a parameter, which is always allowed to span multiple lines. A violation of this rule occurs whenever a
             parameter other than the first parameter spans across multiple lines, and the parameter does not contain an
             anonymous method.</para>
            
             <para>For example, the following code would violate this rule, since the second parameter spans across multiple
             lines:</para>
            
             <code language="csharp">
             return JoinStrings(
                 "John",
                 "Smith" +
                 " Doe");
             </code>
            
             <para>When parameters other than the first parameter span across multiple lines, it can be difficult to tell how
             many parameters are passed to the method. In general, the code becomes difficult to read.</para>
            
             <para>To fix the example above, ensure that the parameters after the first parameter do not span across multiple
             lines. If this will cause a parameter to be excessively long, store the value of the parameter within a
             temporary variable. For example:</para>
            
             <code language="csharp">
             string last = "Smith" +
                 " Doe";
            
             return JoinStrings(
                 "John",
                 last);
             </code>
            
             <para>In some cases, this will allow the method to be written even more concisely, such as:</para>
            
             <code language="csharp">
             return JoinStrings("John", last);
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1118ParameterMustNotSpanMultipleLines.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1118ParameterMustNotSpanMultipleLines"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1118ParameterMustNotSpanMultipleLines.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1118ParameterMustNotSpanMultipleLines.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1120CommentsMustContainText">
            <summary>
            The C# comment does not contain any comment text.
            </summary>
            <remarks>
            <para>A violation of this rule occurs whenever the code contains a C# comment which does not contain any
            text.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1120CommentsMustContainText.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1120CommentsMustContainText"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1120CommentsMustContainText.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1120CommentsMustContainText.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1121UseBuiltInTypeAlias">
             <summary>
             The code uses one of the basic C# types, but does not use the built-in alias for the type.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when one of the following types are used anywhere in the code:
             <c>Boolean</c>, <c>Byte</c>, <c>Char</c>, <c>Decimal</c>, <c>Double</c>, <c>Int16</c>, <c>Int32</c>,
             <c>Int64</c>, <c>Object</c>, <c>SByte</c>, <c>Single</c>, <c>String</c>, <c>UInt16</c>, <c>UInt32</c>,
             <c>UInt64</c>.</para>
            
             <para>A violation also occurs when any of these types are represented in the code using the full namespace for
             the type:
             <c>System.Boolean</c>, <c>System.Byte</c>, <c>System.Char</c>, <c>System.Decimal</c>, <c>System.Double</c>,
             <c>System.Int16</c>, <c>System.Int32</c>, <c>System.Int64</c>, <c>System.Object</c>, <c>System.SByte</c>,
             <c>System.Single</c>, <c>System.String</c>, <c>System.UInt16</c>, <c>System.UInt32</c>,
             <c>System.UInt64</c>.</para>
            
             <para>Rather than using the type name or the fully-qualified type name, the built-in aliases for these types
             should always be used: <c>bool</c>, <c>byte</c>, <c>char</c>, <c>decimal</c>, <c>double</c>, <c>short</c>,
             <c>int</c>, <c>long</c>, <c>object</c>, <c>sbyte</c>, <c> float</c>, <c>string</c>, <c>ushort</c>, <c>uint</c>,
             <c>ulong</c>.</para>
            
             <para>The following table lists each of these types in all three formats:</para>
            
             <list type="table">
             <listheader>
               <term>Type Alias</term>
               <term>Type</term>
               <term>Fully-Qualified Type</term>
             </listheader>
             <item>
               <description>bool</description>
               <description>Boolean</description>
               <description>System.Boolean</description>
             </item>
             <item>
               <description>byte</description>
               <description>Byte</description>
               <description>System.Byte</description>
             </item>
             <item>
               <description>char</description>
               <description>Char</description>
               <description>System.Char</description>
             </item>
             <item>
               <description>decimal</description>
               <description>Decimal</description>
               <description>System.Decimal</description>
             </item>
             <item>
               <description>double</description>
               <description>Double</description>
               <description>System.Double</description>
             </item>
             <item>
               <description>short</description>
               <description>Int16</description>
               <description>System.Int16</description>
             </item>
             <item>
               <description>int</description>
               <description>Int32</description>
               <description>System.Int32</description>
             </item>
             <item>
               <description>long</description>
               <description>Int64</description>
               <description>System.Int64</description>
             </item>
             <item>
               <description>object</description>
               <description>Object</description>
               <description>System.Object</description>
             </item>
             <item>
               <description>sbyte</description>
               <description>SByte</description>
               <description>System.SByte</description>
             </item>
             <item>
               <description>float</description>
               <description>Single</description>
               <description>System.Single</description>
             </item>
             <item>
               <description>string</description>
               <description>String</description>
               <description>System.String</description>
             </item>
             <item>
               <description>ushort</description>
               <description>UInt16</description>
               <description>System.UInt16</description>
             </item>
             <item>
               <description>uint</description>
               <description>UInt32</description>
               <description>System.UInt32</description>
             </item>
             <item>
               <description>ulong</description>
               <description>UInt64</description>
               <description>System.UInt64</description>
             </item>
             </list>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1121UseBuiltInTypeAlias.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1121UseBuiltInTypeAlias"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1121UseBuiltInTypeAlias.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1121UseBuiltInTypeAlias.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1122UseStringEmptyForEmptyStrings">
             <summary>
             The C# code includes an empty string, written as <c>""</c>.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the code contains an empty string. For example:</para>
            
             <code language="csharp">
             string s = "";
             </code>
            
             <para>This will cause the compiler to embed an empty string into the compiled code. Rather than including a
             hard-coded empty string, use the static <see cref="F:System.String.Empty"/> field:</para>
            
             <code language="csharp">
             string s = string.Empty;
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1122UseStringEmptyForEmptyStrings.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1122UseStringEmptyForEmptyStrings"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1122UseStringEmptyForEmptyStrings.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1122UseStringEmptyForEmptyStrings.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1123DoNotPlaceRegionsWithinElements">
            <summary>
            The C# code contains a region within the body of a code element.
            </summary>
            <remarks>
            <para>A violation of this rule occurs whenever a region is placed within the body of a code element. In many
            editors, including Visual Studio, the region will appear collapsed by default, hiding the code within the
            region. It is generally a bad practice to hide code within the body of an element, as this can lead to bad
            decisions as the code is maintained over time.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1123DoNotPlaceRegionsWithinElements.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1123DoNotPlaceRegionsWithinElements"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1123DoNotPlaceRegionsWithinElements.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1123DoNotPlaceRegionsWithinElements.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1123DoNotPlaceRegionsWithinElements.IsCompletelyContainedInBody(Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax)">
            <summary>
            Checks if a region is completely part of a body. That means that the <c>#region</c> and <c>#endregion</c>
            tags both have to have a common <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax"/> as one of their ancestors.
            </summary>
            <param name="regionSyntax">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax"/> that should be analyzed.</param>
            <returns><see langword="true"/>, if both tags have a common <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax"/> as one of their
            ancestors; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="regionSyntax"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1124DoNotUseRegions">
            <summary>
            The C# code contains a region.
            </summary>
            <remarks>
            <para>A violation of this rule occurs whenever a region is placed anywhere within the code. In many editors,
            including Visual Studio, the region will appear collapsed by default, hiding the code within the region. It is
            generally a bad practice to hide code, as this can lead to bad decisions as the code is maintained over
            time.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1124DoNotUseRegions.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1124DoNotUseRegions"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1124DoNotUseRegions.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1124DoNotUseRegions.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1125UseShorthandForNullableTypes">
            <summary>
            The <see cref="T:System.Nullable`1"/> type has been defined not using the C# shorthand. For example,
            <c>Nullable&lt;DateTime&gt;</c> has been used instead of the preferred <c>DateTime?</c>.
            </summary>
            <remarks>
            <para>A violation of this rule occurs whenever the <see cref="T:System.Nullable`1"/> type has been defined without using
            the shorthand C# style.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1125UseShorthandForNullableTypes.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1125UseShorthandForNullableTypes"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1125UseShorthandForNullableTypes.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1125UseShorthandForNullableTypes.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1126PrefixCallsCorrectly">
             <summary>
             A call to a member is not prefixed with the <c>this.</c>, <c>base.</c>, <c>object.</c> or <c>typename.</c>
             prefix to indicate the intended method call, within a C# code file.
             </summary>
             <remarks>
             <para>This diagnostic is not implemented in StyleCopAnalyzers.</para>
            
             <para>A violation of this rule occurs whenever the code contains a call to a member which is not prefixed
             correctly.</para>
            
             <para>In some case from source code analysis we cannot be sure which prefix is required. It could be
             <c>this</c>, <c>base</c>, <c>object</c>, the typename of the class we're in, or one of our base classes.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1126PrefixCallsCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1126PrefixCallsCorrectly"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1126PrefixCallsCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1126PrefixCallsCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1127GenericTypeConstraintsMustBeOnOwnLine">
            <summary>
            Generic type constraints must be on their own line.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when one or more generic type constraints following the <c>where</c>
            keyword are on the same line.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1127GenericTypeConstraintsMustBeOnOwnLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1127GenericTypeConstraintsMustBeOnOwnLine"/>
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1127GenericTypeConstraintsMustBeOnOwnLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1127GenericTypeConstraintsMustBeOnOwnLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1128ConstructorInitializerMustBeOnOwnLine">
            <summary>
            A constructor initializer is on the same line as the constructor declaration, within a C# code file.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1128ConstructorInitializerMustBeOnOwnLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1128ConstructorInitializerMustBeOnOwnLine"/>
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1128ConstructorInitializerMustBeOnOwnLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1128ConstructorInitializerMustBeOnOwnLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1129DoNotUseDefaultValueTypeConstructor">
            <summary>
            A value type was constructed using the syntax <c>new T()</c>.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1129DoNotUseDefaultValueTypeConstructor.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1129DoNotUseDefaultValueTypeConstructor"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1129DoNotUseDefaultValueTypeConstructor.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1129DoNotUseDefaultValueTypeConstructor.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1130UseLambdaSyntax">
            <summary>
            An anonymous method was declared using the form <c>delegate (parameters) { }</c>, when a lambda expression would
            provide equivalent behavior with the syntax <c>(parameters) => { }</c>.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1130UseLambdaSyntax.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1130UseLambdaSyntax"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1130UseLambdaSyntax.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1130UseLambdaSyntax.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1131UseReadableConditions">
            <summary>
            A comparison was made between a variable and a literal or constant value, and the variable appeared on the
            right-hand-side of the expression.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1131UseReadableConditions.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1131UseReadableConditions"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1131UseReadableConditions.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1131UseReadableConditions.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1132DoNotCombineFields">
            <summary>
            Two or more fields were declared in the same field declaration syntax.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1132DoNotCombineFields.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1132DoNotCombineFields"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1132DoNotCombineFields.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1132DoNotCombineFields.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1133DoNotCombineAttributes">
            <summary>
            Two or more attribute uses appeared within the same set of square brackets.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1133DoNotCombineAttributes.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1133DoNotCombineAttributes"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1133DoNotCombineAttributes.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1133DoNotCombineAttributes.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1134AttributesMustNotShareLine">
            <summary>
            An attribute is placed on the same line of code as another attribute or element.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1134AttributesMustNotShareLine.FixWithNewLineBeforeKey">
            <summary>
            Properties key used to indicate that a code fix should be inserted before the attribute.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1134AttributesMustNotShareLine.FixWithNewLineAfterKey">
            <summary>
            Properties key used to indicate that a code fix should be inserted after the attribute.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1134AttributesMustNotShareLine.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1134AttributesMustNotShareLine"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1134AttributesMustNotShareLine.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1134AttributesMustNotShareLine.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.ReadabilityRules.SA1136EnumValuesShouldBeOnSeparateLines">
            <summary>
            Enum values should be placed on their own lines for maximum readability.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SA1136EnumValuesShouldBeOnSeparateLines.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SA1136EnumValuesShouldBeOnSeparateLines"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SA1136EnumValuesShouldBeOnSeparateLines.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SA1136EnumValuesShouldBeOnSeparateLines.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="F:StyleCop.Analyzers.ReadabilityRules.SX1101DoNotPrefixLocalMembersWithThis.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.ReadabilityRules.SX1101DoNotPrefixLocalMembersWithThis"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.ReadabilityRules.SX1101DoNotPrefixLocalMembersWithThis.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.ReadabilityRules.SX1101DoNotPrefixLocalMembersWithThis.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.DeserializationFailureBehavior">
            <summary>
            Defines the behavior of various <see cref="T:StyleCop.Analyzers.SettingsHelper"/> methods in the event of a deserialization error.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.DeserializationFailureBehavior.ReturnDefaultSettings">
            <summary>
            When deserialization fails, return a default <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings"/> instance.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.DeserializationFailureBehavior.ThrowException">
            <summary>
            When deserialization fails, throw a <see cref="T:Newtonsoft.Json.JsonException"/> containing details about the error.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.AbbreviationSettings.abbreviationsToSkip">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.AbbreviationSettings.AbbreviationsToSkip"/> property.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Settings.ObjectModel.AbbreviationSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.AbbreviationSettings"/> class during JSON deserialization.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.DefaultCompanyName">
            <summary>
            The default value for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.CompanyName"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.DefaultCopyrightText">
            <summary>
            The default value for the <see cref="M:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.GetCopyrightText(System.String)"/> method.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.companyName">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.CompanyName"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.copyrightText">
            <summary>
            This is the backing field for the <see cref="M:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.GetCopyrightText(System.String)"/> method.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.copyrightTextCache">
            <summary>
            This is the cache for the <see cref="M:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.GetCopyrightText(System.String)"/> method.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.headerDecoration">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.HeaderDecoration"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.variables">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.Variables"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.xmlHeader">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.XmlHeader"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.documentExposedElements">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.DocumentExposedElements"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.documentInternalElements">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.DocumentInternalElements"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.documentPrivateElements">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.DocumentPrivateElements"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.documentInterfaces">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.DocumentInterfaces"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.documentPrivateFields">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.DocumentPrivateFields"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.fileNamingConvention">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.FileNamingConvention"/> property.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings"/> class during JSON deserialization.
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.Settings.ObjectModel.EndOfFileHandling">
            <summary>
            Specifies the handling for newline characters which appear at the end of a file.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.EndOfFileHandling.Allow">
            <summary>
            Files are allowed to end with a single newline character, but it is not required.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.EndOfFileHandling.Require">
            <summary>
            Files are required to end with a single newline character.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.EndOfFileHandling.Omit">
            <summary>
            Files may not end with a newline character.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.FileNamingConvention.StyleCop">
            <summary>
            Files are named using the StyleCop convention (e.g. TypeName{T1,T2})
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.FileNamingConvention.Metadata">
            <summary>
            Files are named using the metadata convention (e.g. TypeName`2)
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.IndentationSettings.indentationSize">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.IndentationSettings.IndentationSize"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.IndentationSettings.tabSize">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.IndentationSettings.TabSize"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.IndentationSettings.useTabs">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.IndentationSettings.UseTabs"/> property.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Settings.ObjectModel.IndentationSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.IndentationSettings"/> class during JSON deserialization.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.LayoutSettings.newlineAtEndOfFile">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.LayoutSettings.NewlineAtEndOfFile"/> property.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Settings.ObjectModel.LayoutSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.LayoutSettings"/> class during JSON deserialization.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Settings.ObjectModel.MaintainabilitySettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.MaintainabilitySettings"/> class during JSON deserialization.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.NamingSettings.allowCommonHungarianPrefixes">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.NamingSettings.AllowCommonHungarianPrefixes"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.NamingSettings.allowedHungarianPrefixes">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.NamingSettings.AllowedHungarianPrefixes"/> property.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Settings.ObjectModel.NamingSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.NamingSettings"/> class during JSON deserialization.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.OrderingSettings.elementOrder">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.OrderingSettings.ElementOrder"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.OrderingSettings.systemUsingDirectivesFirst">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.OrderingSettings.SystemUsingDirectivesFirst"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.OrderingSettings.usingDirectivesPlacement">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.OrderingSettings.UsingDirectivesPlacement"/> property.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Settings.ObjectModel.OrderingSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.OrderingSettings"/> class during JSON deserialization.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.OrderingTrait.Kind">
            <summary>
            Elements are ordered according to their kind.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.OrderingTrait.Accessibility">
            <summary>
            Code elements are ordered according to their declared accessibility.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.OrderingTrait.Constant">
            <summary>
            Constant elements are ordered before non-constant elements.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.OrderingTrait.Static">
            <summary>
            Static elements are ordered before non-static elements.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.OrderingTrait.Readonly">
            <summary>
            Readonly elements are ordered before non-readonly elements.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Settings.ObjectModel.ReadabilitySettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.ReadabilitySettings"/> class during JSON deserialization.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.SettingsFile.settings">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.SettingsFile.Settings"/> property.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Settings.ObjectModel.SettingsFile.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.SettingsFile"/> class
            during JSON deserialization.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Settings.ObjectModel.SpacingSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.SpacingSettings"/> class during JSON deserialization.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.indentation">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.Indentation"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.spacingRules">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.SpacingRules"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.readabilityRules">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.ReadabilityRules"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.orderingRules">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.OrderingRules"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.namingRules">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.NamingRules"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.maintainabilityRules">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.MaintainabilityRules"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.layoutRules">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.LayoutRules"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.documentationRules">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.DocumentationRules"/> property.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.abbreviationRules">
            <summary>
            This is the backing field for the <see cref="P:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.AbbreviationRules"/> property.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings"/> class during JSON deserialization.
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.Settings.ObjectModel.UsingDirectivesPlacement">
            <summary>
            Specifies the desired placement of using directives.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.UsingDirectivesPlacement.InsideNamespace">
            <summary>
            Place using directives inside the namespace definition.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.UsingDirectivesPlacement.OutsideNamespace">
            <summary>
            Place using directives outside the namespace definition.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.Settings.ObjectModel.UsingDirectivesPlacement.Preserve">
            <summary>
            Allow using directives inside or outside the namespace definition.
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.Settings.SettingsResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.Settings.SettingsResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.Settings.SettingsResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.Settings.SettingsResources.SettingsFileCodeFix">
            <summary>
              Looks up a localized string similar to Add StyleCop settings file to the project.
            </summary>
        </member>
        <member name="T:StyleCop.Analyzers.SettingsHelper">
            <summary>
            Class that manages the settings files for StyleCopAnalyzers.
            </summary>
        </member>
        <member name="M:StyleCop.Analyzers.SettingsHelper.GetStyleCopSettings(Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext,System.Threading.CancellationToken)">
            <summary>
            Gets the StyleCop settings.
            </summary>
            <remarks>
            <para>If a <see cref="T:Newtonsoft.Json.JsonException"/> occurs while deserializing the settings file, a default settings
            instance is returned.</para>
            </remarks>
            <param name="context">The context that will be used to determine the StyleCop settings.</param>
            <param name="cancellationToken">The cancellation token that the operation will observe.</param>
            <returns>A <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings"/> instance that represents the StyleCop settings for the given context.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.SettingsHelper.GetStyleCopSettings(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,System.Threading.CancellationToken)">
            <summary>
            Gets the StyleCop settings.
            </summary>
            <remarks>
            <para>If a <see cref="T:Newtonsoft.Json.JsonException"/> occurs while deserializing the settings file, a default settings
            instance is returned.</para>
            </remarks>
            <param name="options">The analyzer options that will be used to determine the StyleCop settings.</param>
            <param name="cancellationToken">The cancellation token that the operation will observe.</param>
            <returns>A <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings"/> instance that represents the StyleCop settings for the given context.</returns>
        </member>
        <member name="M:StyleCop.Analyzers.SettingsHelper.GetStyleCopSettings(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,StyleCop.Analyzers.DeserializationFailureBehavior,System.Threading.CancellationToken)">
            <summary>
            Gets the StyleCop settings.
            </summary>
            <param name="options">The analyzer options that will be used to determine the StyleCop settings.</param>
            <param name="failureBehavior">The behavior of the method when a <see cref="T:Newtonsoft.Json.JsonException"/> occurs while
            deserializing the settings file.</param>
            <param name="cancellationToken">The cancellation token that the operation will observe.</param>
            <returns>A <see cref="T:StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings"/> instance that represents the StyleCop settings for the given context.</returns>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1000KeywordsMustBeSpacedCorrectly">
             <summary>
             The spacing around a C# keyword is incorrect.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around a keyword is incorrect.</para>
            
             <para>The following C# keywords must always be followed by a single space: <strong>catch</strong>,
             <strong>fixed</strong>, <strong>for</strong>, <strong>foreach</strong>, <strong>from</strong>,
             <strong>group</strong>, <strong>if</strong>, <strong>in</strong>, <strong>into</strong>, <strong>join</strong>,
             <strong>let</strong>, <strong>lock</strong>, <strong>orderby</strong>, <strong>return</strong>,
             <strong>select</strong>, <strong>stackalloc</strong>, <strong>switch</strong>, <strong>throw</strong>,
             <strong>using</strong>, <strong>where</strong>, <strong>while</strong>, <strong>yield</strong>.</para>
            
             <para>The following keywords must not be followed by any space: <strong>checked</strong>,
             <strong>default</strong>, <strong>sizeof</strong>, <strong>typeof</strong>, <strong>unchecked</strong>.</para>
            
             <para>The <strong>new</strong> keyword should always be followed by a space, unless it is used to create a new
             array, in which case there should be no space between the new keyword and the opening array bracket.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1000KeywordsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1000KeywordsMustBeSpacedCorrectly"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1000KeywordsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1000KeywordsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1001CommasMustBeSpacedCorrectly">
             <summary>
             The spacing around a comma is incorrect, within a C# code file.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around a comma is incorrect.</para>
            
             <para>A comma should always be followed by a single space, unless it is the last character on the line, and a
             comma should never be preceded by any whitespace, unless it is the first character on the line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1001CommasMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1001CommasMustBeSpacedCorrectly"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1001CommasMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1001CommasMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1002SemicolonsMustBeSpacedCorrectly">
             <summary>
             The spacing around a semicolon is incorrect, within a C# code file.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around a semicolon is incorrect.</para>
            
             <para>A semicolon should always be followed by a single space, unless it is the last character on the line, and
             a semicolon should never be preceded by any whitespace, unless it is the first character on the line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1002SemicolonsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1002SemicolonsMustBeSpacedCorrectly"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1002SemicolonsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1002SemicolonsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1003SymbolsMustBeSpacedCorrectly">
             <summary>
             The spacing around an operator symbol is incorrect, within a C# code file.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around an operator symbol is incorrect.</para>
            
             <para>The following types of operator symbols must be surrounded by a single space on either side: colons,
             arithmetic operators, assignment operators, conditional operators, logical operators, relational operators,
             shift operators, and lambda operators. For example:</para>
            
             <code language="cs">
             int x = 4 + y;
             </code>
            
             <para>In contrast, unary operators must be preceded by a single space, but must never be followed by any space.
             For example:</para>
            
             <code language="cs">
             bool x = !value;
             </code>
            
             <para>An exception occurs whenever the symbol is preceded or followed by a parenthesis or bracket, in which case
             there should be no space between the symbol and the bracket. For example:</para>
            
             <code language="cs">
             if (!value)
             {
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1003SymbolsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1003SymbolsMustBeSpacedCorrectly"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1003SymbolsMustBeSpacedCorrectly.DescriptorNotFollowedByComment">
            <summary>
            Gets the descriptor for prefix unary expression that may not be followed by a comment.
            </summary>
            <value>
            A diagnostic descriptor.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1003SymbolsMustBeSpacedCorrectly.DescriptorPrecededByWhitespace">
            <summary>
            Gets the descriptor indicating that an operator must be preceded by whitespace.
            </summary>
            <value>
            A diagnostic descriptor.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1003SymbolsMustBeSpacedCorrectly.DescriptorNotPrecededByWhitespace">
            <summary>
            Gets the descriptor indicating that an operator must be preceded by whitespace.
            </summary>
            <value>
            A diagnostic descriptor.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1003SymbolsMustBeSpacedCorrectly.DescriptorFollowedByWhitespace">
            <summary>
            Gets the descriptor indicating that an operator must be followed by whitespace.
            </summary>
            <value>
            A diagnostic descriptor.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1003SymbolsMustBeSpacedCorrectly.DescriptorNotFollowedByWhitespace">
            <summary>
            Gets the descriptor indicating that an operator must be preceded by whitespace.
            </summary>
            <value>
            A diagnostic descriptor.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1003SymbolsMustBeSpacedCorrectly.DescriptorNotAtEndOfLine">
            <summary>
            Gets the descriptor indicating that an operator must be appear at the end of a text line.
            </summary>
            <value>
            A diagnostic descriptor.
            </value>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1003SymbolsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1003SymbolsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1004DocumentationLinesMustBeginWithSingleSpace">
             <summary>
             A line within a documentation header above a C# element does not begin with a single space.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when a line within a documentation header does not begin with a single
             space. For example:</para>
            
             <code language="cs">
             ///&lt;summary&gt;
             ///The summary text.
             ///&lt;/summary&gt;
             ///   &lt;param name="x"&gt;The document root.&lt;/param&gt;
             ///    &lt;param name="y"&gt;The Xml header token.&lt;/param&gt;
             private void Method1(int x, int y)
             {
             }
             </code>
            
             <para>The header lines should begin with a single space after the three leading forward slashes:</para>
            
             <code language="cs">
             /// &lt;summary&gt;
             /// The summary text.
             /// &lt;/summary&gt;
             /// &lt;param name="x"&gt;The document root.&lt;/param&gt;
             /// &lt;param name="y"&gt;The Xml header token.&lt;/param&gt;
             private void Method1(int x, int y)
             {
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1004DocumentationLinesMustBeginWithSingleSpace.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1004DocumentationLinesMustBeginWithSingleSpace"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1004DocumentationLinesMustBeginWithSingleSpace.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1004DocumentationLinesMustBeginWithSingleSpace.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1005SingleLineCommentsMustBeginWithSingleSpace">
             <summary>
             A single-line comment within a C# code file does not begin with a single space.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when a single-line comment does not begin with a single space. For
             example:</para>
            
             <code language="cs">
             private void Method1()
             {
                 //A single-line comment.
                 //   A single-line comment.
             }
             </code>
            
             <para>The comments should begin with a single space after the leading forward slashes:</para>
            
             <code language="cs">
             private void Method1()
             {
                 // A single-line comment.
                 // A single-line comment.
             }
             </code>
            
             <para>An exception to this rule occurs when the comment is being used to comment out a line of code. In this
             case, the space can be omitted if the comment begins with four forward slashes to indicate out-commented code.
             For example:</para>
            
             <code language="cs">
             private void Method1()
             {
                 ////int x = 2;
                 ////return x;
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1005SingleLineCommentsMustBeginWithSingleSpace.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1005SingleLineCommentsMustBeginWithSingleSpace"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1005SingleLineCommentsMustBeginWithSingleSpace.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1005SingleLineCommentsMustBeginWithSingleSpace.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1006PreprocessorKeywordsMustNotBePrecededBySpace">
             <summary>
             A C# preprocessor-type keyword is preceded by space.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the preprocessor-type keyword in a preprocessor directive is preceded
             by space. For example:</para>
            
             <code language="cs">
             # if DEBUG
             </code>
            
             <para>There should not be any whitespace between the opening hash mark and the preprocessor-type keyword:</para>
            
             <code language="cs">
             #if DEBUG
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1006PreprocessorKeywordsMustNotBePrecededBySpace.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1006PreprocessorKeywordsMustNotBePrecededBySpace"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1006PreprocessorKeywordsMustNotBePrecededBySpace.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1006PreprocessorKeywordsMustNotBePrecededBySpace.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1007OperatorKeywordMustBeFollowedBySpace">
             <summary>
             The operator keyword within a C# operator overload method is not followed by any whitespace.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the operator keyword within an operator overload method is not
             followed by any whitespace. The operator keyword should always be followed by a single space. For
             example:</para>
            
             <code language="cs">
             public MyClass operator +(MyClass a, MyClass b)
             {
             }
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1007OperatorKeywordMustBeFollowedBySpace.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1007OperatorKeywordMustBeFollowedBySpace"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1007OperatorKeywordMustBeFollowedBySpace.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1007OperatorKeywordMustBeFollowedBySpace.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1008OpeningParenthesisMustBeSpacedCorrectly">
             <summary>
             An opening parenthesis within a C# statement is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the opening parenthesis within a statement is not spaced correctly.
             An opening parenthesis should not be preceded by any whitespace, unless it is the first character on the line,
             or it is preceded by certain C# keywords such as if, while, or for. In addition, an opening parenthesis is
             allowed to be preceded by whitespace when it follows an operator symbol within an expression.</para>
            
             <para>An opening parenthesis should not be followed by whitespace, unless it is the last character on the
             line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1008OpeningParenthesisMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1008OpeningParenthesisMustBeSpacedCorrectly"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1008OpeningParenthesisMustBeSpacedCorrectly.DescriptorNotPreceded">
            <summary>
            Gets the diagnostic descriptor for an opening parenthesis that must not be preceded by whitespace.
            </summary>
            <value>The diagnostic descriptor for an opening parenthesis that must not be preceded by whitespace.</value>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1008OpeningParenthesisMustBeSpacedCorrectly.DescriptorPreceded">
            <summary>
            Gets the diagnostic descriptor for an opening parenthesis that must be preceded by whitespace.
            </summary>
            <value>The diagnostic descriptor for an opening parenthesis that must be preceded by whitespace.</value>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1008OpeningParenthesisMustBeSpacedCorrectly.DescriptorNotFollowed">
            <summary>
            Gets the diagnostic descriptor for an opening parenthesis that must not be followed by whitespace.
            </summary>
            <value>The diagnostic descriptor for an opening parenthesis that must not be followed by whitespace.</value>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1008OpeningParenthesisMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1008OpeningParenthesisMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1009ClosingParenthesisMustBeSpacedCorrectly">
             <summary>
             A closing parenthesis within a C# statement is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the closing parenthesis within a statement is not spaced
             correctly.</para>
            
             <para>A closing parenthesis should never be preceded by whitespace. In most cases, a closing parenthesis should
             be followed by a single space, unless the closing parenthesis comes at the end of a cast, or the closing
             parenthesis is followed by certain types of operator symbols, such as positive signs, negative signs, and
             colons.</para>
            
             <para>If the closing parenthesis is followed by whitespace, the next non-whitespace character must not be an
             opening or closing parenthesis or square bracket, or a semicolon or comma.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1009ClosingParenthesisMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1009ClosingParenthesisMustBeSpacedCorrectly"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1009ClosingParenthesisMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1009ClosingParenthesisMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1010OpeningSquareBracketsMustBeSpacedCorrectly">
             <summary>
             An opening square bracket within a C# statement is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when an opening square bracket within a statement is preceded or followed
             by whitespace.</para>
            
             <para>An opening square bracket must never be preceded by whitespace, unless it is the first character on the
             line, and an opening square must never be followed by whitespace, unless it is the last character on the
             line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1010OpeningSquareBracketsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1010OpeningSquareBracketsMustBeSpacedCorrectly"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1010OpeningSquareBracketsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1010OpeningSquareBracketsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1011ClosingSquareBracketsMustBeSpacedCorrectly">
             <summary>
             A closing square bracket within a C# statement is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around a closing square bracket is not correct.</para>
            
             <para>A closing square bracket must never be preceded by whitespace, unless it is the first character on the
             line.</para>
            
             <para>A closing square bracket must be followed by whitespace, unless it is the last character on the line, it
             is followed by a closing bracket or an opening parenthesis, it is followed by a comma or semicolon, or it is
             followed by certain types of operator symbols.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1011ClosingSquareBracketsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1011ClosingSquareBracketsMustBeSpacedCorrectly"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1011ClosingSquareBracketsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1011ClosingSquareBracketsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1012OpeningBracesMustBeSpacedCorrectly">
             <summary>
             An opening brace within a C# element is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around an opening brace is not correct.</para>
            
             <para>An opening brace should always be preceded by a single space, unless it is the first character on the
             line, or unless it is preceded by an opening parenthesis, in which case there should be no space between the
             parenthesis and the brace.</para>
            
             <para>An opening brace must always be followed by a single space, unless it is the last character on the
             line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1012OpeningBracesMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1012OpeningBracesMustBeSpacedCorrectly"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1012OpeningBracesMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1012OpeningBracesMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1013ClosingBracesMustBeSpacedCorrectly">
             <summary>
             A closing brace within a C# element is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around a closing brace is not correct.</para>
            
             <para>A closing brace should always be followed by a single space, unless it is the last character on the line,
             or unless it is followed by a closing parenthesis, a comma, a semicolon, or a member access operator.</para>
            
             <para>A closing brace must always be preceded by a single space, unless it is the first character on the
             line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1013ClosingBracesMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1013ClosingBracesMustBeSpacedCorrectly"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1013ClosingBracesMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1013ClosingBracesMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1014OpeningGenericBracketsMustBeSpacedCorrectly">
             <summary>
             An opening generic bracket within a C# element is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around an opening generic bracket is not correct.</para>
            
             <para>An opening generic bracket should never be preceded or followed by whitespace, unless the bracket is the
             first or last character on the line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1014OpeningGenericBracketsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1014OpeningGenericBracketsMustBeSpacedCorrectly"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1014OpeningGenericBracketsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1014OpeningGenericBracketsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1015ClosingGenericBracketsMustBeSpacedCorrectly">
             <summary>
             A closing generic bracket within a C# element is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around a closing generic bracket is not correct.</para>
            
             <para>A closing generic bracket should never be preceded by whitespace, unless the bracket is the first
             character on the line. A closing generic bracket should be followed by an open parenthesis, a close parenthesis,
             a closing generic bracket, a nullable symbol, an end of line or a single whitespace (but not whitespace and an
             open parenthesis).</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1015ClosingGenericBracketsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1015ClosingGenericBracketsMustBeSpacedCorrectly"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1015ClosingGenericBracketsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1015ClosingGenericBracketsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1016OpeningAttributeBracketsMustBeSpacedCorrectly">
             <summary>
             An opening attribute bracket within a C# element is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around an opening attribute bracket is not
             correct.</para>
            
             <para>An opening attribute bracket should never be followed by whitespace, unless the bracket is the last
             character on the line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1016OpeningAttributeBracketsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1016OpeningAttributeBracketsMustBeSpacedCorrectly"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1016OpeningAttributeBracketsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1016OpeningAttributeBracketsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1017ClosingAttributeBracketsMustBeSpacedCorrectly">
             <summary>
             A closing attribute bracket within a C# element is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around a closing attribute bracket is not correct.</para>
            
             <para>A closing attribute bracket should never be preceded by whitespace, unless the bracket is the first
             character on the line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1017ClosingAttributeBracketsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1017ClosingAttributeBracketsMustBeSpacedCorrectly"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1017ClosingAttributeBracketsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1017ClosingAttributeBracketsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1018NullableTypeSymbolsMustNotBePrecededBySpace">
             <summary>
             A nullable type symbol within a C# element is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around a nullable type symbol is not correct.</para>
            
             <para>A nullable type symbol should never be preceded by whitespace.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1018NullableTypeSymbolsMustNotBePrecededBySpace.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1018NullableTypeSymbolsMustNotBePrecededBySpace"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1018NullableTypeSymbolsMustNotBePrecededBySpace.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1018NullableTypeSymbolsMustNotBePrecededBySpace.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1019MemberAccessSymbolsMustBeSpacedCorrectly">
            <summary>
            The spacing around a member access symbol is incorrect, within a C# code file.
            </summary>
            <remarks>
            <para>A violation of this rule occurs when the spacing around a member access symbol is incorrect. A member
            access symbol should not have whitespace on either side, unless it is the first character on the line.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1019MemberAccessSymbolsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1019MemberAccessSymbolsMustBeSpacedCorrectly"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1019MemberAccessSymbolsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1019MemberAccessSymbolsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1020IncrementDecrementSymbolsMustBeSpacedCorrectly">
             <summary>
             An increment or decrement symbol within a C# element is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around an increment or decrement symbol is not
             correct.</para>
            
             <para>There should be no whitespace between the increment or decrement symbol and the item that is being
             incremented or decremented.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1020IncrementDecrementSymbolsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1020IncrementDecrementSymbolsMustBeSpacedCorrectly"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1020IncrementDecrementSymbolsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1020IncrementDecrementSymbolsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1021NegativeSignsMustBeSpacedCorrectly">
             <summary>
             A negative sign within a C# element is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around a negative sign is not correct.</para>
            
             <para>A negative sign should always be preceded by a single space, unless it comes after an opening square
             bracket, a parenthesis, or is the first character on the line.</para>
            
             <para>A negative sign should never be followed by whitespace, and should never be the last character on a
             line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1021NegativeSignsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1021NegativeSignsMustBeSpacedCorrectly"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1021NegativeSignsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1021NegativeSignsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1022PositiveSignsMustBeSpacedCorrectly">
             <summary>
             A positive sign within a C# element is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around a positive sign is not correct.</para>
            
             <para>A positive sign should always be preceded by a single space, unless it comes after an opening square
             bracket, a parenthesis, or is the first character on the line.</para>
            
             <para>A positive sign should never be followed by whitespace, and should never be the last character on a
             line.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1022PositiveSignsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1022PositiveSignsMustBeSpacedCorrectly"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1022PositiveSignsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1022PositiveSignsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1023DereferenceAndAccessOfSymbolsMustBeSpacedCorrectly">
             <summary>
             A dereference symbol or an access-of symbol within a C# element is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around a dereference or access-of symbol is not
             correct.</para>
            
             <para>The spacing around the symbol depends upon whether the symbol is used within a type declaration. If so,
             the symbol must always be followed by a single space, unless it is the last character on the line, or is
             followed by an opening square bracket or a parenthesis. In addition, the symbol should not be preceded by
             whitespace, and should not be the first character on the line. An example of a properly spaced dereference
             symbol used within a type declaration is:</para>
            
             <code language="cs">
             object* x = null;
             </code>
            
             <para>When a dereference or access-of symbol is used outside of a type declaration, the opposite rule applies.
             In this case, the symbol must always be preceded by a single space, unless it is the first character on the
             line, or is preceded by an opening square bracket, a parenthesis or a symbol of the same type i.e. an equals.
             The symbol should not be followed by whitespace, and should not be the last character on the line. For
             example:</para>
            
             <code language="cs">
             y = *x;
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1023DereferenceAndAccessOfSymbolsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.SpacingRules.SA1023DereferenceAndAccessOfSymbolsMustBeSpacedCorrectly"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1023DereferenceAndAccessOfSymbolsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1023DereferenceAndAccessOfSymbolsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1024ColonsMustBeSpacedCorrectly">
             <summary>
             A colon within a C# element is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs when the spacing around a colon is not correct.</para>
            
             <para>The spacing around a colon depends upon the type of colon and how it is used within the code. A colon
             appearing within an element declaration must always have a single space on either side, unless it is the first
             or last character on the line. For example all of the colons below follow this rule:</para>
            
             <code language="cs">
             public class Class2&lt;T&gt; : Class1 where T : MyType
             {
                 public Class2(int x) : base(x)
                 {
                 }
             }
             </code>
            
             <para>When the colon comes at the end of a label or case statement, it must always be followed by whitespace or
             be the last character on the line, but should never be preceded by whitespace. For example:</para>
            
             <code language="cs">
             _label:
             switch (x)
             {
                 case 2:
                     return x;
             }
             </code>
            
             <para>Finally, when a colon is used within a conditional statement, it must always contain a single space on
             either side, unless the colon is the first or last character on the line. For example:</para>
            
             <code language="cs">
             int x = y ? 2 : 3;
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1024ColonsMustBeSpacedCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1024ColonsMustBeSpacedCorrectly"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1024ColonsMustBeSpacedCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1024ColonsMustBeSpacedCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1025CodeMustNotContainMultipleWhitespaceInARow">
            <summary>
            The code contains multiple whitespace characters in a row.
            </summary>
            <remarks>
            <para>A violation of this rule occurs whenever the code contains multiple whitespace characters in a row, unless
            the characters come at the beginning or end of a line of code, following a comma or semicolon or preceding a
            symbol.</para>
            </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1025CodeMustNotContainMultipleWhitespaceInARow.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1025CodeMustNotContainMultipleWhitespaceInARow"/>
            analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1025CodeMustNotContainMultipleWhitespaceInARow.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1025CodeMustNotContainMultipleWhitespaceInARow.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1026CodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation">
             <summary>
             An implicitly typed new array allocation within a C# code file is not spaced correctly.
             </summary>
             <remarks>
             <para>A violation of this rule occurs whenever the code contains an implicitly typed new array allocation which
             is not spaced correctly. Within an implicitly typed new array allocation, there should not be any space between
             the new keyword and the opening array bracket. For example:</para>
            
             <code language="cs">
             var a = new[] { 1, 10, 100, 1000 };
             </code>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1026CodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the
            <see cref="T:StyleCop.Analyzers.SpacingRules.SA1026CodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1026CodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1026CodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1027UseTabsCorrectly">
            <summary>
            The code contains a tab or space character which is not consistent with the current project settings.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1027UseTabsCorrectly.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1027UseTabsCorrectly"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1027UseTabsCorrectly.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1027UseTabsCorrectly.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SA1028CodeMustNotContainTrailingWhitespace">
             <summary>
             Discovers any C# lines of code with trailing whitespace.
             </summary>
             <remarks>
             <para>A violation of this rule occurs whenever the code contains whitespace at the end of the line.</para>
            
             <para>Trailing whitespace causes unnecessary diffs in source control,
             looks tacky in editors that show invisible whitespace as visible characters,
             and is highlighted as an error in some configurations of git.</para>
            
             <para>For these reasons, trailing whitespace should be avoided.</para>
             </remarks>
        </member>
        <member name="F:StyleCop.Analyzers.SpacingRules.SA1028CodeMustNotContainTrailingWhitespace.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpacingRules.SA1028CodeMustNotContainTrailingWhitespace"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SA1028CodeMustNotContainTrailingWhitespace.SupportedDiagnostics">
            <inheritdoc />
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1028CodeMustNotContainTrailingWhitespace.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc />
        </member>
        <member name="M:StyleCop.Analyzers.SpacingRules.SA1028CodeMustNotContainTrailingWhitespace.HandleSyntaxTree(Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext)">
            <summary>
            Scans an entire document for lines with trailing whitespace.
            </summary>
            <param name="context">The context that provides the document to scan.</param>
        </member>
        <member name="T:StyleCop.Analyzers.SpacingRules.SpacingResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1003CodeFix">
            <summary>
              Looks up a localized string similar to Fix spacing.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1004CodeFix">
            <summary>
              Looks up a localized string similar to Fix spacing.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1004Description">
            <summary>
              Looks up a localized string similar to A line within a documentation header above a C# element does not begin with a single space..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1004MessageFormat">
            <summary>
              Looks up a localized string similar to Documentation line must begin with a space..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1004Title">
            <summary>
              Looks up a localized string similar to Documentation lines must begin with single space.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1005CodeFix">
            <summary>
              Looks up a localized string similar to Fix spacing.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1005Description">
            <summary>
              Looks up a localized string similar to A single-line comment within a C# code file does not begin with a single space..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1005MessageFormat">
            <summary>
              Looks up a localized string similar to Single line comment must begin with a space..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1005Title">
            <summary>
              Looks up a localized string similar to Single line comments must begin with single space.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1006Description">
            <summary>
              Looks up a localized string similar to A C# preprocessor-type keyword is preceded by space..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1006MessageFormat">
            <summary>
              Looks up a localized string similar to Preprocessor keyword &apos;{0}&apos; must not be preceded by a space..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1006Title">
            <summary>
              Looks up a localized string similar to Preprocessor keywords must not be preceded by space.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1007Description">
            <summary>
              Looks up a localized string similar to The operator keyword within a C# operator overload method is not followed by any whitespace..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1007MessageFormat">
            <summary>
              Looks up a localized string similar to Operator keyword must be followed by a space..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1007Title">
            <summary>
              Looks up a localized string similar to Operator keyword must be followed by space.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1008CodeFix">
            <summary>
              Looks up a localized string similar to Fix spacing.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1016Description">
            <summary>
              Looks up a localized string similar to An opening attribute bracket within a C# element is not spaced correctly..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1016MessageFormat">
            <summary>
              Looks up a localized string similar to Opening attribute brackets must not be followed by a space..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1016Title">
            <summary>
              Looks up a localized string similar to Opening attribute brackets must be spaced correctly.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1017Description">
            <summary>
              Looks up a localized string similar to A closing attribute bracket within a C# element is not spaced correctly..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1017MessageFormat">
            <summary>
              Looks up a localized string similar to Closing attribute brackets must not be preceded by a space..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1017Title">
            <summary>
              Looks up a localized string similar to Closing attribute brackets must be spaced correctly.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1018CodeFix">
            <summary>
              Looks up a localized string similar to Fix spacing.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1018Description">
            <summary>
              Looks up a localized string similar to A nullable type symbol within a C# element is not spaced correctly..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1018MessageFormat">
            <summary>
              Looks up a localized string similar to Nullable type symbol must not be preceded by a space..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1018Title">
            <summary>
              Looks up a localized string similar to Nullable type symbols must be spaced correctly.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1025CodeFix">
            <summary>
              Looks up a localized string similar to Fix spacing.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1025Description">
            <summary>
              Looks up a localized string similar to The code contains multiple whitespace characters in a row..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1025MessageFormat">
            <summary>
              Looks up a localized string similar to Code must not contain multiple whitespace characters in a row..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1025Title">
            <summary>
              Looks up a localized string similar to Code must not contain multiple whitespace in a row.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1026Description">
            <summary>
              Looks up a localized string similar to An implicitly typed new array allocation within a C# code file is not spaced correctly..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1026MessageFormat">
            <summary>
              Looks up a localized string similar to The keyword &apos;new&apos; must not be followed by a space or a blank line..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1026Title">
            <summary>
              Looks up a localized string similar to Code must not contain space after new keyword in implicitly typed array allocation.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1027CodeFix">
            <summary>
              Looks up a localized string similar to Replace tabs with spaces.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1027Description">
            <summary>
              Looks up a localized string similar to The code contains a tab or space character which is not consistent with the current project settings..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1027MessageFormat">
            <summary>
              Looks up a localized string similar to Tabs and spaces should be used correctly.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1027Title">
            <summary>
              Looks up a localized string similar to Use tabs correctly.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1028CodeFix">
            <summary>
              Looks up a localized string similar to Remove trailing whitespace.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1028Description">
            <summary>
              Looks up a localized string similar to There should not be any whitespace at the end of a line of code..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1028MessageFormat">
            <summary>
              Looks up a localized string similar to Code must not contain trailing whitespace.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.SA1028Title">
            <summary>
              Looks up a localized string similar to Code must not contain trailing whitespace.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.SpacingResources.TokenSpacingCodeFix">
            <summary>
              Looks up a localized string similar to Fix spacing.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpacingRules.TokenSpacingProperties.RemoveImmediatePreceding">
            <summary>
            Gets a property collection indicating that the code fix should remove any
            <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia"/> trivia which <em>immediately</em> precedes the token identified by
            the diagnostic span.
            </summary>
            <value>
            A property collection indicating that the code fix should remove any
            <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia"/> trivia which <em>immediately</em> precedes the token identified by
            the diagnostic span.
            </value>
        </member>
        <member name="T:StyleCop.Analyzers.SpecialRules.SA0001XmlCommentAnalysisDisabled">
            <summary>
            The project is configured to not parse XML documentation comments.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.SpecialRules.SA0001XmlCommentAnalysisDisabled.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpecialRules.SA0001XmlCommentAnalysisDisabled"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpecialRules.SA0001XmlCommentAnalysisDisabled.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpecialRules.SA0001XmlCommentAnalysisDisabled.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpecialRules.SA0002InvalidSettingsFile">
            <summary>
            The <em>stylecop.json</em> settings file could not be loaded due to a deserialization failure.
            </summary>
        </member>
        <member name="F:StyleCop.Analyzers.SpecialRules.SA0002InvalidSettingsFile.DiagnosticId">
            <summary>
            The ID for diagnostics produced by the <see cref="T:StyleCop.Analyzers.SpecialRules.SA0002InvalidSettingsFile"/> analyzer.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpecialRules.SA0002InvalidSettingsFile.SupportedDiagnostics">
            <inheritdoc/>
        </member>
        <member name="M:StyleCop.Analyzers.SpecialRules.SA0002InvalidSettingsFile.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <inheritdoc/>
        </member>
        <member name="T:StyleCop.Analyzers.SpecialRules.SpecialResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpecialRules.SpecialResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpecialRules.SpecialResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpecialRules.SpecialResources.SA0001Description">
            <summary>
              Looks up a localized string similar to XML comment analysis can only be performed when the project is configured to parse documentation comments. To enable this functionality, update the project to produce an XML documentation file as part of the build..
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpecialRules.SpecialResources.SA0001MessageFormat">
            <summary>
              Looks up a localized string similar to XML comment analysis is disabled due to project configuration.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpecialRules.SpecialResources.SA0001Title">
            <summary>
              Looks up a localized string similar to XML comment analysis disabled.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpecialRules.SpecialResources.SA0002Description">
             <summary>
               Looks up a localized string similar to Various errors in the stylecop.json file can prevent the file from being loaded by the analyzers. In this case, the default settings are used instead.
            
            {0}.
             </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpecialRules.SpecialResources.SA0002MessageFormat">
            <summary>
              Looks up a localized string similar to The stylecop.json settings file could not be loaded.
            </summary>
        </member>
        <member name="P:StyleCop.Analyzers.SpecialRules.SpecialResources.SA0002Title">
            <summary>
              Looks up a localized string similar to Invalid settings file.
            </summary>
        </member>
        <member name="T:System.Linq.SyntaxTriviaListEnumerable">
            <summary>
            This class supports a subset of LINQ operations on <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> without requiring boxing of
            operands as an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:System.Linq.SyntaxTriviaListEnumerable.Contains(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Determines if a <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> contains a specific <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/>.
            </summary>
            <remarks>
            <para>This method allows callers to avoid boxing the <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> as an
            <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</para>
            </remarks>
            <param name="list">The source list.</param>
            <param name="trivia">The element to look for in the list.</param>
            <returns>
            <see langword="true"/> if <paramref name="list"/> contains <paramref name="trivia"/>; otherwise,
            <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Linq.SyntaxTriviaListEnumerable.Any(Microsoft.CodeAnalysis.SyntaxTriviaList,System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Determines if a <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> contains any trivia matching the conditions specified by a
            predicate.
            </summary>
            <remarks>
            <para>This method allows callers to avoid boxing the <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> as an
            <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</para>
            </remarks>
            <param name="list">The <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> to search.</param>
            <param name="predicate">The predicate determining the matching conditions for trivia.</param>
            <returns>
            <see langword="true"/> if the specified list contains any trivia matching the specified predicate;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Linq.SyntaxTriviaListEnumerable.All(Microsoft.CodeAnalysis.SyntaxTriviaList,System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Determines if all of the trivia in a <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> match the conditions specified by a
            predicate.
            </summary>
            <remarks>
            <para>This method allows callers to avoid boxing the <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> as an
            <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</para>
            </remarks>
            <param name="list">The <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> to search.</param>
            <param name="predicate">The predicate determining the matching conditions for trivia.</param>
            <returns>
            <see langword="true"/> if all trivia in the specified list match the specified predicate; otherwise,
            <see langword="false"/>. If the list is empty, this method returns <see langword="true"/>.
            </returns>
        </member>
        <member name="M:System.Linq.SyntaxTriviaListEnumerable.LastOrDefault(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Returns the last trivia of a specified kind in a trivia list.
            </summary>
            <param name="list">The trivia list.</param>
            <param name="kind">The syntax kind.</param>
            <returns>The last <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/> in <paramref name="list"/> with the specified
            <paramref name="kind"/>; otherwise, a default <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/> instance if no matching trivia was
            found.</returns>
        </member>
    </members>
</doc>
